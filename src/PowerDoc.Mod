(* ETH Oberon, Copyright 1990-2003 Computer Systems Institute, ETH Zurich, CH-8092 Zurich.Refer to the license.txt file provided with this distribution. *)MODULE PowerDoc; (*JG 11.8.98*)  IMPORT Input, Display, Objects, Viewers, Files, Modules, Fonts, Texts, Oberon, Attributes, Links, Pictures, Rembrandt,    Gadgets, Out;(* Basic syntax  CompilationUnit = { Lib | Doc }.  Lib = "(" LIB name { Frame } ")" [ comment ].  Doc = "(" DOC [ name ] { DocSpecs } ") [ comment ].  DocSpecs = Meta | Frame | StreamDef.  Meta = "(" META string ")" [ comment ].  Frame = "(" FRAME [ name ] { FrameSpecs } ")" [ comment ].  FrameSpecs =     Position | Size | BG | Object |    Grid | Padding | Boundary | Separators |    Frame | StreamDef | StreamImp |    Declaration.  Position = "(" POS num "@" num ")" [ comment ].  Size = "(" SIZE num "@" num ")" [ comment ].  Grid = "(" GRID { Extent } "@" { Extent } ")" [ comment ].  Extent = num ":" ( num [ "%" ] | "*" ) [ comment ].  Padding = "(" PAD num [ "@" num ] ")" [ comment ].  Boundary = "(" BND num [ "@" num ] ")" [ comment ].  Separators = "(" SEP num [ "@" num ] ")" [ comment ].  BG = "(" BG name ")" [ comment ].  Object = "(" OBJ name { Declaration } ")" [ comment ].  StreamDef = "(" STD name Dest ")" [ comment ].  StreamImp = "(" STI name Dest ")" [ comment ].  Dest = "(" DST { name } ")" | "(" DSP [ num "@" num" ] ")" [ comment ].  Declaration = "(" name Object ")" [ comment ]. *)  CONST    Inval = Texts.Inval; Name = Texts.Name; String = Texts.String; Int = Texts.Int; Real = Texts.Real; Char = Texts.Char;    Obj = 100; Head = 101; Tail = 102; (*additional symbol classes*)    MaxCells = 16; MaxLen = 50; MinInt = -32768; eps = 1.0E-6;    CR = 0DX;  TYPE    Declaration = POINTER TO RECORD      next: Declaration;      class: INTEGER;      obj: Object;      i: LONGINT;      x: REAL;      s: ARRAY 32 OF CHAR;      name: ARRAY 16 OF CHAR    END;    Scope = POINTER TO RECORD      up: Scope;      par: INTEGER;      lead: INTEGER;      lib: Objects.Library;      col: INTEGER;      voff: INTEGER;      com: LONGINT (*command position*)    END;    WordReader = RECORD (Texts.Reader)      text: Texts.Text;      scope: Scope;      pos: LONGINT;      len, wid: INTEGER;      nextCh: CHAR;      str: ARRAY MaxLen OF CHAR    END;    RefPoint = POINTER TO RECORD      next: RefPoint;      scope: Scope;      pos: LONGINT;      Y: INTEGER    END;    Destination = POINTER TO RECORD      next: Destination;      frame: Frame    END;    Stream = POINTER TO RECORD      next: Stream;      text: Texts.Text;      HPad, VPad: REAL;      scope: Scope;      pos: LONGINT;      terminal: BOOLEAN;      ref: RefPoint;      dst, lastDst: Destination;      name: ARRAY 32 OF CHAR    END;    Frame* = POINTER TO RECORD      anc, next: Frame; (*ancestor, sibbling*)      dsc, lastDsc: Frame; (*descendants*)      dcl, lastDcl: Declaration; (*declarations*)      std, lastStd: Stream; (*stream declarations*)      sti, lastSti: Stream; (*stream imports*)      R, C, RSpan, CSpan: INTEGER; (*location/size in terms of grid position*)      X, Y, W, H: REAL; (*location/size*)      obj: Object; (*contents object*)      BGP: Pictures.Picture; (*background pattern*)      HPad, VPad: REAL; (*padding*)      HBnd, VBnd: REAL; (*boundary*)      HSep, VSep: REAL; (*separating lines*)      eofRows, eofCols: INTEGER; (*grid structure*)      RP, CP: ARRAY 32 OF REAL; (*size/pos, > 0: abs, = 0: auto, < 0: rel*)      name, BGPName: ARRAY 32 OF CHAR    END;    Object = POINTER TO RECORD      next: Object;      obx: Objects.Object; (*associated Oberon object*)      attr, lastAttr: Declaration; (*attributes*)      gen: ARRAY 32 OF CHAR (*generator*)    END;    Document* = POINTER TO RECORD (Frame)      view: Viewer;      meta: ARRAY 64 OF CHAR    END;    Viewer = POINTER TO RECORD (Viewers.Viewer)      isOverlay: BOOLEAN;      doc: Document;      frame: Frame    END;    Context* = RECORD      doc*: Document;      frame*: Frame;      text*: Texts.Text;      pos*: LONGINT;      keys*: SET;      X*, Y*: INTEGER;      XW, YW, WW: INTEGER    END;  VAR    C*: Context; S: Texts.Scanner;     nofErr: INTEGER; ind: INTEGER; SW, SH: INTEGER; box: Fonts.Char;    DefaultScope: Scope; BoxPat: ARRAY 12 OF SET;    LibOp, DocOp, MetaOp, FrameOp, StrDefOp, StrImpOp, ObjOp, DstOp, DspOp,    PosOp, SizeOp, GridOp, BGOp, ParOp, PadOp, BndOp, SepOp, FontOp, ColOp,    LeadOp, ImpOp, CmdOp: ARRAY 4 OF CHAR;    res: ARRAY 1000 OF CHAR; (*resources*)(*** Error reports ***)  PROCEDURE PErr (item: ARRAY OF CHAR);  BEGIN INC(nofErr);    Out.String("pos "); Out.Int(Texts.Pos(S), 1); Out.Char(" ");    Out.String(item); Out.String(" expected"); Out.Ln;    GetSym  END PErr;  PROCEDURE Err (msg: ARRAY OF CHAR);  BEGIN INC(nofErr); Out.String(msg); Out.Ln  END Err;(*** Scanner support ***)  PROCEDURE GetSym;  BEGIN Texts.Scan(S);    IF S.class = Char THEN      IF S.c = "(" THEN Texts.Scan(S); S.class := Head        ELSIF S.c = ")" THEN S.class := Tail      END    ELSIF S.class = Int THEN S.x := S.i    END  END GetSym;  PROCEDURE Matching (VAR s, t: ARRAY OF CHAR): BOOLEAN;    VAR i: INTEGER;  BEGIN i := 0;    WHILE (s[i] # 0X) & (t[i] # 0X) & (s[i] = t[i]) DO INC(i) END;    RETURN t[i] = 0X  END Matching;  PROCEDURE CheckTail (item: ARRAY OF CHAR);  BEGIN IF S.class = Tail THEN GetSym ELSE PErr(item) END;    IF S.class = Name THEN GetSym END  END CheckTail;(*** Text Reader support ***)  PROCEDURE ReadWord (VAR WR: WordReader);    VAR i, w: INTEGER; ch: CHAR; obj: Objects.Object;   BEGIN Texts.Read(WR, ch);    WHILE ~WR.eot & (ch <= " ") DO INC(WR.pos); Texts.Read(WR, ch) END;    i := 0; w := 0;    WHILE ~WR.eot & (ch > " ") & (i # MaxLen) DO WR.str[i] := ch;      IF WR.scope.lib IS Fonts.Font THEN        WR.scope.lib.GetObj(WR.scope.lib, ORD(ch), obj); w := w + obj(Fonts.Char).dx      ELSE w := w + box.dx      END;      INC(i); Texts.Read(WR, ch)    END;    WR.len := i; WR.wid := w; WR.nextCh := ch  END ReadWord;  PROCEDURE ReadTextWord* (VAR WR: WordReader);    VAR pos: LONGINT; pbal: INTEGER; ch: CHAR; fnt: Fonts.Font;      local: Scope; cont, old, new: Frame; obj: Object;  BEGIN    WR.pos := Texts.Pos(WR); ReadWord(WR);    IF WR.len = 2 THEN      IF (WR.str[0] = "{") & (WR.str[1] = "%") THEN        NEW(local); local^ := WR.scope^; local.up := WR.scope;        WR.scope := local; pos := Texts.Pos(WR);        Texts.OpenScanner(S, WR.text, pos); GetSym;        LOOP          IF S.class # Head THEN EXIT END;          IF Matching(S.s, FontOp) THEN GetSym;            IF S.class = Name THEN fnt := Fonts.This(S.s);              IF fnt # NIL THEN WR.scope.lib := fnt END;              GetSym (*tail*)            END           ELSIF Matching(S.s, ColOp) THEN GetSym;            IF S.class = Int THEN WR.scope.col := SHORT(S.i); GetSym END          ELSIF Matching(S.s, ParOp) THEN GetSym;            IF S.class = Int THEN WR.scope.par := SHORT(S.i); GetSym END          ELSIF Matching(S.s, LeadOp) THEN GetSym;            IF S.class = Int THEN WR.scope.lead := SHORT(S.i); GetSym END          ELSIF Matching(S.s, CmdOp) THEN WR.scope.com := Texts.Pos(S);            GetSym;            IF S.class = Name THEN pbal := 1;               REPEAT Texts.Scan(S);                IF S.class = Char THEN                  IF S.c = "(" THEN INC(pbal) ELSIF S.c = ")" THEN DEC(pbal) END                END              UNTIL pbal = 0            END          END;          pos := Texts.Pos(S); (*pos after tail*)          GetSym        END;        Texts.OpenReader(WR, WR.text, pos); ReadTextWord(WR)      ELSIF (WR.str[0] = "%") & (WR.str[1] = "}") THEN        IF WR.scope.up # NIL THEN WR.scope := WR.scope.up END;        ReadTextWord(WR)      END    END  END ReadTextWord;(*** Object support ***)  PROCEDURE ModifySize (F: Display.Frame; W, H: INTEGER);    VAR M: Display.ModifyMsg;  BEGIN    IF (F # NIL) & ((F.W # W) OR (F.H # H)) THEN      M.id := Display.extend; M.mode := Display.state; M.F := F;      M.X := F.X; M.Y := F.Y + F.H - H; M.W := W; M.H := H;      M.dW := W - F.W; M.dH := H - F.H; M.dX := 0; M.dY := -M.dH;      M.dlink := NIL; M.x := 0; M.y := 0; M.res := -1; Objects.Stamp(M);      F.handle(F, M)    END  END ModifySize;  PROCEDURE ConsumeObj (F, f: Display.Frame; u, v: INTEGER);    VAR C: Display.ConsumeMsg;  BEGIN    IF (F # NIL) & (f # NIL) THEN f.slink := NIL;      C.id := Display.drop; C.F := F; C.res := -1; C.dlink := NIL; C.x := 0; C.y := 0;      C.u := u; C.v := v; C.obj := f; F.handle(F, C)	END  END ConsumeObj;  PROCEDURE GetPublicObj (name: ARRAY OF CHAR; VAR obj: Objects.Object);    VAR i, j, k, ref: INTEGER; lib: Objects.Library;      objname: ARRAY 32 OF CHAR;  BEGIN i := 0;    WHILE (name[i] # 0X) & (name[i] # ".") DO INC(i); END;    IF name[i] = "." THEN INC(i); j := i; k := 0;      WHILE name[j] # 0X DO objname[k] := name[j]; INC(j); INC(k) END;      objname[k] := 0X;	  name[i] := "L"; name[i+1] := "i"; name[i+2] := "b"; name[i+3] := 0X;	  lib := Objects.ThisLibrary(name);	  IF lib # NIL THEN		Objects.GetRef(lib.dict, objname, ref);		IF ref # MIN(INTEGER) THEN lib.GetObj(lib, ref, obj); END	  END    ELSE obj := NIL    END  END GetPublicObj;  PROCEDURE CopyPublicObj (name: ARRAY OF CHAR; deep: BOOLEAN): Objects.Object;    VAR C: Objects.CopyMsg; obj: Objects.Object;  BEGIN    GetPublicObj(name, obj);	IF obj # NIL THEN Objects.Stamp(C); C.obj := NIL;      IF deep THEN C.id := Objects.deep ELSE C.id := Objects.shallow END;      obj.handle(obj, C); obj := C.obj    END;    RETURN obj  END CopyPublicObj;  PROCEDURE CreateObj (gen: ARRAY OF CHAR): Objects.Object;    VAR res: INTEGER;  BEGIN Objects.NewObj := NIL;    Oberon.Call(gen, Oberon.Par, FALSE, res); RETURN Objects.NewObj  END CreateObj;  PROCEDURE BindObj (obj: Objects.Object; lib: Objects.Library);    VAR ref: INTEGER; M: Objects.BindMsg;  BEGIN    IF lib # NIL THEN       IF (obj.lib = NIL) OR (obj.lib.name[0] = 0X) & (obj.lib # lib) THEN lib.GenRef(lib, ref);        IF ref >= 0 THEN lib.PutObj(lib, ref, obj); M.lib := lib; obj.handle(obj, M) END      END    END  END BindObj;  PROCEDURE Update (obj: Objects.Object);    VAR MU: Gadgets.UpdateMsg; MD: Display.DisplayMsg;  BEGIN    IF obj IS Display.Frame THEN      MD.device := Display.screen; MD.id := Display.full; MD.F := obj(Display.Frame); Display.Broadcast(MD)	ELSE MU.obj := obj; MU.F := NIL; Display.Broadcast(MU)    END  END Update;(*** Composer, seventh pass: display foreground ***)  PROCEDURE INT (x: REAL): INTEGER;  BEGIN RETURN SHORT(ENTIER(x + 0.5))  END INT;  PROCEDURE RFStream (str: Stream; frame: Frame; VAR WR: WordReader);    VAR XS, XE, XC, YC, YE, lsp, i: INTEGER; fnt: Fonts.Font; char: Fonts.Char; obj: Objects.Object;    ref, lastRef: RefPoint;  BEGIN    XS := INT(frame.X + str.HPad); XE := INT(frame.X + frame.W - str.HPad);    YC := INT(frame.Y + frame.H - str.VPad); YE := INT(frame.Y + str.VPad);    lastRef := NIL;    IF WR.scope.lib IS Fonts.Font THEN      fnt := WR.scope.lib(Fonts.Font); lsp := fnt.height + WR.scope.lead    ELSE lsp := box.h + WR.scope.lead    END;    IF (WR.len = 2) & (WR.str[0] = "%") & (WR.str[1] = "\") THEN      lsp := lsp + WR.scope.par; ReadTextWord(WR)    END;    WHILE ~WR.eot & (YC >= YE + lsp) DO YC := YC - lsp; XC := XS;      NEW(ref); ref.Y := YC; ref.scope := WR.scope; ref.pos := WR.pos;      IF lastRef # NIL THEN lastRef.next := ref ELSE str.ref := ref END;      lastRef := ref;      WHILE ~WR.eot & ((WR.len # 2) OR (WR.str[0] # "%") OR (WR.str[1] # "\")) & (XC + WR.wid <= XE) DO        i := 0;        WHILE i # WR.len DO          IF WR.scope.lib IS Fonts.Font THEN            WR.scope.lib.GetObj(WR.scope.lib, ORD(WR.str[i]), obj); char := obj(Fonts.Char)          ELSE char := box          END;          Display.CopyPattern(WR.scope.col, char.pat, XC + char.x, YC + char.y, Display.paint);          XC := XC + char.dx;          INC(i)        END;        WR.lib.GetObj(WR.lib, ORD(" "), obj); char := obj(Fonts.Char);        XC := XC + char.dx;        ReadTextWord(WR)      END;      IF ~WR.eot THEN        IF WR.scope.lib IS Fonts.Font THEN          fnt := WR.scope.lib(Fonts.Font); lsp := fnt.height + WR.scope.lead        ELSE lsp := box.h + WR.scope.lead        END;        IF (WR.len = 2) & (WR.str[0] = "%") & (WR.str[1] = "\") THEN          lsp := lsp + WR.scope.par; ReadTextWord(WR)        END      END    END  END RFStream;  PROCEDURE DFStream (str: Stream; frame: Frame; VAR WR: WordReader);    VAR sti: Stream; dst: Destination;  BEGIN sti := frame.sti;    WHILE (sti # NIL) & (sti.name # str.name) DO sti := sti.next END;    IF sti # NIL THEN      sti.text := str.text; sti.scope := WR.scope; sti.pos := WR.pos; (*late eval*)      IF sti.terminal THEN RFStream(sti, frame, WR)      ELSE dst := sti.dst;        WHILE ~WR.eot & (dst # NIL) DO DFStream(sti, dst.frame, WR); dst := dst.next END      END    END  END DFStream;  PROCEDURE DFFrame (frame: Frame);    VAR dsc: Frame; str: Stream; dst: Destination; WR: WordReader; i, j: INTEGER;      Mapped: ARRAY MaxCells, MaxCells OF BOOLEAN;  BEGIN    dsc := frame.dsc;    WHILE dsc # NIL DO DFFrame(dsc); dsc := dsc.next END;    IF frame.HBnd > 0 THEN      Display.ReplConst(Display.FG, INT(frame.X), INT(frame.Y), INT(frame.W), INT(frame.HBnd), Display.replace);      Display.ReplConst(Display.FG, INT(frame.X), INT(frame.Y) + INT(frame.H) - INT(frame.HBnd),        INT(frame.W), INT(frame.HBnd), Display.replace)    END;    IF frame.VBnd > 0 THEN      Display.ReplConst(Display.FG, INT(frame.X), INT(frame.Y), INT(frame.VBnd), INT(frame.H), Display.replace);      Display.ReplConst(Display.FG, INT(frame.X) + INT(frame.W) - INT(frame.VBnd), INT(frame.Y),        INT(frame.VBnd), INT(frame.H), Display.replace)    END;    IF (frame.HSep > 0) OR (frame.VSep > 0) THEN      FOR i := 0 TO MaxCells-1 DO        FOR j := 0 TO MaxCells-1 DO Mapped[i, j] := FALSE END      END;      dsc := frame.dsc;      WHILE dsc # NIL DO        FOR i := 0 TO dsc.RSpan-1 DO Mapped[dsc.R + i, dsc.C] := TRUE END;        FOR j := 0 TO dsc.CSpan-1 DO Mapped[dsc.R, dsc.C + j] := TRUE END;        dsc := dsc.next      END;      dsc := frame.dsc;      WHILE dsc # NIL DO        IF frame.HSep > 0 THEN          Display.ReplConst(Display.FG, INT(dsc.X) - INT(frame.HPad/2), INT(dsc.Y) - INT(frame.VPad/2),            INT(dsc.W) + INT(frame.HPad), INT(frame.HSep), Display.replace);          IF ~Mapped[dsc.R + dsc.RSpan, dsc.C] THEN            Display.ReplConst(Display.FG, INT(dsc.X) - INT(frame.HPad/2), INT(dsc.Y + dsc.H) + INT(frame.HPad/2),              INT(dsc.W) + INT(frame.HPad), INT(frame.HSep), Display.replace)          END        END;        IF frame.VSep > 0 THEN          Display.ReplConst(Display.FG, INT(dsc.X) - INT(frame.HPad/2), INT(dsc.Y) - INT(frame.VPad/2),            INT(frame.VSep), INT(dsc.H) + INT(frame.VPad), Display.replace);          IF ~Mapped[dsc.R, dsc.C + dsc.CSpan] THEN            Display.ReplConst(Display.FG, INT(dsc.X + dsc.W) + INT(frame.VPad/2), INT(dsc.Y) - INT(frame.VPad/2),              INT(frame.VSep), INT(dsc.H) + INT(frame.VPad), Display.replace)          END        END;        dsc := dsc.next      END    END;    str := frame.std;    WHILE str # NIL DO      WR.text := str.text; WR.scope := str.scope;      Texts.OpenReader(WR, str.text, str.pos); ReadTextWord(WR);      IF str.terminal THEN RFStream(str, frame, WR)      ELSE dst := str.dst;        WHILE ~WR.eot & (dst # NIL) DO DFStream(str, dst.frame, WR); dst := dst.next END      END;      str := str.next    END  END DFFrame;(*** Composer, sixth pass: display background ***)  PROCEDURE DBFrame (frame: Frame);    VAR dsc: Frame; X, Y, Xlim, Ylim, col: INTEGER;  BEGIN    IF frame.BGPName[0] # 0X THEN      IF ("0" <= frame.BGPName[0]) & (frame.BGPName[0] <= "9") THEN        col := ORD(frame.BGPName[0]) - ORD("0");        IF ("0" <= frame.BGPName[1]) & (frame.BGPName[1] <= "9") THEN          col := col*10 + ORD(frame.BGPName[1]) - ORD("0")        END;        Display.ReplConst(col, INT(frame.X), INT(frame.Y), INT(frame.W), INT(frame.H), Display.replace)      ELSE (* replicate picture *)        Y := INT(frame.Y); Ylim := Y + INT(frame.H);        WHILE Y + frame.BGP.height <= Ylim DO X := INT(frame.X); Xlim := X + INT(frame.W);          WHILE X + frame.BGP.width <= Xlim DO            Pictures.DisplayBlock(frame.BGP, 0, 0, frame.BGP.width, frame.BGP.height, X, Y, Display.replace);            X := X + frame.BGP.width          END;          IF X < Xlim THEN            Pictures.DisplayBlock(frame.BGP, 0, 0, Xlim - X, frame.BGP.height, X, Y, Display.replace)          END;          Y := Y + frame.BGP.height        END;        IF Y < Ylim THEN X := INT(frame.X); Xlim := X + INT(frame.W);          WHILE X + frame.BGP.width <= Xlim DO            Pictures.DisplayBlock(frame.BGP, 0, 0, frame.BGP.width, Ylim - Y, X, Y, Display.replace);            X := X + frame.BGP.width          END;          IF X < Xlim THEN            Pictures.DisplayBlock(frame.BGP, 0, 0, Xlim - X, Ylim - Y, X, Y, Display.replace)          END        END      END    END;    dsc := frame.dsc;    WHILE dsc # NIL DO DBFrame(dsc); dsc := dsc.next END  END DBFrame;(*** Composer, fifth pass: building/composing ***)  PROCEDURE BFrame (cont, frame: Frame);    VAR dsc: Frame;  BEGIN    IF frame.obj # NIL THEN       ModifySize(frame.obj.obx(Display.Frame), INT(frame.W), INT(frame.H)); dsc := frame.dsc;      WHILE dsc # NIL DO BFrame(frame, dsc); dsc := dsc.next END;      IF (cont # NIL) & (cont.obj # NIL) THEN        ConsumeObj(cont.obj.obx(Display.Frame), frame.obj.obx(Display.Frame),        INT(frame.X) - INT(cont.X), INT(frame.Y) - INT(cont.Y + cont.H) + 2 (*!*))      END    ELSE dsc := frame.dsc;      WHILE dsc # NIL DO BFrame(cont, dsc); dsc := dsc.next END    END  END BFrame;(*** Composer, fourth pass: absolute locating ***)  PROCEDURE RStream (str: Stream; frame: Frame; VAR WR: WordReader);    VAR XS, XE, XC, YC, YE, lsp, i: INTEGER; fnt: Fonts.Font; char: Fonts.Char; obj: Objects.Object;  BEGIN    XS := INT(frame.X + str.HPad); XE := INT(frame.X + frame.W - str.HPad);    YC := INT(frame.Y + frame.H - str.VPad); YE := INT(frame.Y + str.VPad);    IF WR.scope.lib IS Fonts.Font THEN      fnt := WR.scope.lib(Fonts.Font); lsp := fnt.height + WR.scope.lead    ELSE lsp := box.h + WR.scope.lead    END;    IF (WR.len = 2) & (WR.str[0] = "%") & (WR.str[1] = "\") THEN      lsp := lsp + WR.scope.par; ReadTextWord(WR)    END;    WHILE ~WR.eot & (YC >= YE + lsp) DO YC := YC - lsp; XC := XS;      WHILE ~WR.eot & ((WR.len # 2) OR (WR.str[0] # "%") OR (WR.str[1] # "\")) & (XC + WR.wid <= XE) DO        i := 0;        WHILE i # WR.len DO          IF WR.scope.lib IS Fonts.Font THEN            WR.scope.lib.GetObj(WR.scope.lib, ORD(WR.str[i]), obj); char := obj(Fonts.Char)          ELSE char := box          END;          XC := XC + char.dx;          INC(i)        END;        WR.lib.GetObj(WR.lib, ORD(" "), obj); char := obj(Fonts.Char);        XC := XC + char.dx;        ReadTextWord(WR)      END;      IF ~WR.eot THEN        IF WR.scope.lib IS Fonts.Font THEN          fnt := WR.scope.lib(Fonts.Font); lsp := fnt.height + WR.scope.lead        ELSE lsp := box.h + WR.scope.lead        END;        IF (WR.len = 2) & (WR.str[0] = "%") & (WR.str[1] = "\") THEN          lsp := lsp + WR.scope.par; ReadTextWord(WR)        END      END    END  END RStream;  PROCEDURE LStream (str: Stream; frame: Frame; VAR WR: WordReader);    VAR sti: Stream; dst: Destination;  BEGIN sti := frame.sti;    WHILE (sti # NIL) & (sti.name # str.name) DO sti := sti.next END;    IF sti # NIL THEN      sti.text := str.text; sti.scope := WR.scope; sti.pos := WR.pos;      IF sti.terminal THEN RStream(sti, frame, WR)      ELSE dst := sti.dst;        WHILE ~WR.eot & (dst # NIL) DO LStream(sti, dst.frame, WR); dst := dst.next END      END    END  END LStream;  PROCEDURE LFrame (frame: Frame);    VAR dsc: Frame;  BEGIN dsc := frame.dsc;    WHILE dsc # NIL DO      dsc.X := frame.X + frame.HPad + dsc.X; dsc.Y := frame.Y + frame.VPad + dsc.Y; LFrame(dsc);      dsc := dsc.next    END  END LFrame;(*** Composer, third pass: layout computation ***)  PROCEDURE CFrameW (frame: Frame);    VAR dsc: Frame; C, i, j: INTEGER; CP: ARRAY 16 OF REAL;  BEGIN    IF frame.CP[1] = 0 THEN (*auto*) dsc := frame.dsc;      WHILE dsc # NIL DO CFrameW(dsc); dsc := dsc.next END;      i := 1;      WHILE i <= frame.eofCols DO CP[i] := 0; INC(i) END;      i := 1;      WHILE i # frame.eofCols DO dsc := frame.dsc;        WHILE dsc # NIL DO          IF dsc.C = i THEN j := i + dsc.CSpan;            IF CP[j] < CP[i] + frame.HPad + dsc.W THEN CP[j] := CP[i] + frame.HPad + dsc.W END          END;          dsc := dsc.next        END;        INC(i)      END;      IF frame.W = 0 THEN frame.W := CP[frame.eofCols] + frame.HPad END    ELSE      IF frame.CP[1] > 0 THEN (*abs*) CP[1] := 0; i := 1;        WHILE i # frame.eofCols DO CP[i+1] := CP[i] + frame.HPad + frame.CP[i] ; INC(i) END;        IF frame.W = 0 THEN frame.W := CP[frame.eofCols] - frame.HPad END      ELSIF frame.CP[1] < 0 THEN (*rel*)        IF (frame.W = 0) & (frame.obj # NIL) THEN frame.W := frame.obj.obx(Display.Frame).W END;        CP[1] := 0; i := 1;        IF frame.CP[1] = MinInt THEN          WHILE i # frame.eofCols DO            CP[i+1] := CP[i] + 1/(frame.eofCols-1)*(frame.W - frame.HPad); INC(i)          END        ELSE          WHILE i # frame.eofCols DO            CP[i+1] := CP[i] - frame.CP[i]*(frame.W - frame.HPad); INC(i)          END        END      END;      dsc := frame.dsc;      WHILE dsc # NIL DO        dsc.W := CP[dsc.C + dsc.CSpan] - CP[dsc.C] - frame.HPad; CFrameW(dsc); dsc := dsc.next      END    END;    dsc := frame.dsc;    WHILE dsc # NIL DO dsc.X := CP[dsc.C]; dsc := dsc.next END  END CFrameW;  PROCEDURE CFrameH (frame: Frame);    VAR dsc: Frame; R, i, j: INTEGER; RP: ARRAY 16 OF REAL;  BEGIN    IF frame.RP[1] = 0 THEN (*auto*) dsc := frame.dsc;      WHILE dsc # NIL DO CFrameH(dsc); dsc := dsc.next END;      i := 1;      WHILE i <= frame.eofRows DO RP[i] := 0; INC(i) END;      i := 1;      WHILE i # frame.eofRows DO dsc := frame.dsc;        WHILE dsc # NIL DO          IF dsc.R = i THEN j := i + dsc.RSpan;            IF RP[j] < RP[i] + frame.VPad + dsc.H THEN RP[j] := RP[i] + frame.VPad + dsc.H END          END;          dsc := dsc.next        END;        INC(i)      END;      IF frame.H = 0 THEN frame.H := RP[frame.eofRows] + frame.VPad END    ELSE      IF frame.RP[1] > 0 THEN (*abs*) RP[1] := 0; i := 1;        WHILE i # frame.eofRows DO RP[i+1] := RP[i] + frame.VPad + frame.RP[i]; INC(i) END;        IF frame.H = 0 THEN frame.H := RP[frame.eofRows] - frame.VPad END      ELSIF frame.RP[1] < 0 THEN (*rel*)        IF (frame.H = 0) & (frame.obj # NIL) THEN frame.H := frame.obj.obx(Display.Frame).H END;        RP[1] := 0; i := 1;        IF frame.RP[1] = MinInt THEN          WHILE i # frame.eofRows DO            RP[i+1] := RP[i] + 1/(frame.eofRows-1)*(frame.H - frame.VPad); INC(i)          END        ELSE          WHILE i # frame.eofRows DO            RP[i+1] := RP[i] - frame.RP[i]*(frame.H - frame.VPad); INC(i)          END        END      END;      dsc := frame.dsc;      WHILE dsc # NIL DO        dsc.H := RP[dsc.R + dsc.RSpan] - RP[dsc.R] - frame.VPad; CFrameH(dsc); dsc := dsc.next      END    END;    dsc := frame.dsc;    WHILE dsc # NIL DO dsc.Y := RP[dsc.R]; dsc := dsc.next END  END CFrameH;(*** Composer, second pass: object generation ***)  PROCEDURE Find (scope: Frame; VAR name: ARRAY OF CHAR; VAR dcl: Declaration);  BEGIN    REPEAT dcl := scope.dcl;      WHILE (dcl # NIL) & (dcl.name # name) DO dcl := dcl.next END;      scope := scope.anc    UNTIL (dcl # NIL) OR (scope = NIL)  END Find;  PROCEDURE ExtensionIS (VAR name: ARRAY OF CHAR; ext: ARRAY OF CHAR): BOOLEAN;    VAR i, j: INTEGER;  BEGIN i := 0;    WHILE (name[i] # 0X) & (name[i] # ".") DO INC(i) END;    IF name[i] = "." THEN INC(i) END;    j := 0;    WHILE (name[i] # 0X) & (ext[j] # 0X) & (name[i] = ext[j]) DO INC(i); INC(j) END;    RETURN name[i] = ext[j]  END ExtensionIS;  PROCEDURE New (VAR gen: ARRAY OF CHAR): Objects.Object;    VAR obx: Objects.Object; F: Rembrandt.Frame; P: Pictures.Picture; M: Objects.AttrMsg;  BEGIN    IF ExtensionIS(gen, "Pict") THEN      NEW(P); Pictures.Open(P, gen, TRUE);      IF (P.width > 0) & (P.height > 0) THEN NEW(F); Rembrandt.NewP(F, P); obx := F        ELSE obx := NIL      END    ELSE obx := CopyPublicObj(gen, TRUE);      IF obx = NIL THEN obx := CreateObj(gen) END    END;    IF obx = NIL THEN Err("object generation failed") END;    RETURN obx  END New;  PROCEDURE SetAttr (obx: Objects.Object; VAR name: ARRAY OF CHAR; VAR dcl: Declaration);  BEGIN     IF dcl.class = String THEN Attributes.SetString(obx, name, dcl.s)      ELSIF dcl.class = Int THEN Attributes.SetInt(obx, name, dcl.i)      ELSIF dcl.class = Real THEN Attributes.SetReal(obx, name, dcl.x)      ELSIF dcl.class = Obj THEN Links.SetLink(obx, name, dcl.obj.obx)    END  END SetAttr;  PROCEDURE GObject (scope: Frame; obj: Object);    VAR attr, dcl: Declaration;  BEGIN    obj.obx := New(obj.gen);    IF obj.obx # NIL THEN attr := obj.attr;      WHILE attr # NIL DO dcl := NIL;        IF attr.class = Name THEN Find(scope, attr.s, dcl);          IF dcl # NIL THEN SetAttr(obj.obx, attr.name, dcl)            ELSE Err("attribute not found")          END        ELSE SetAttr(obj.obx, attr.name, attr)        END;        attr := attr.next      END    END  END GObject;  PROCEDURE GStream (str: Stream);    VAR f: Files.File; len: LONGINT;  BEGIN f := Files.Old(str.name);    IF f # NIL THEN NEW(str.text); Texts.Load(str.text, f, 1, len)      ELSE Err("invalid text name")    END  END GStream;  PROCEDURE GFrame (frame: Frame);    VAR dcl: Declaration; dsc: Frame; str: Stream;  BEGIN    IF frame.obj # NIL THEN GObject(frame, frame.obj);      IF (frame.obj.obx # NIL) & ~(frame.obj.obx IS Display.Frame) THEN        Err("not a display frame")      END    END;    IF frame.BGPName[0] # 0X THEN      IF ("0" > frame.BGPName[0]) OR (frame.BGPName[0] > "9") THEN        NEW(frame.BGP); Pictures.Open(frame.BGP, frame.BGPName, TRUE);        IF (frame.BGP.width = 0) OR (frame.BGP.height = 0) THEN Err("invalid picture") END      END    END;    dcl := frame.dcl;    WHILE (nofErr = 0) & (dcl # NIL) DO      IF dcl.class = Obj THEN GObject(frame, dcl.obj) END;      dcl := dcl.next    END;    dsc := frame.dsc;    WHILE (nofErr = 0) & (dsc # NIL) DO GFrame(dsc); dsc := dsc.next END;    str := frame.std;    WHILE str # NIL DO GStream(str); str := str.next END  END GFrame;(*** Composer, first pass: parsing & internalization ***)  PROCEDURE PStream (anc: Frame; VAR str: Stream);    VAR dst: Destination; frame: Frame;  BEGIN NEW(str); GetSym;    IF S.class = Name THEN COPY(S.s, str.name); GetSym;      IF Matching(S.s, DstOp) THEN GetSym;        WHILE S.class = Name DO NEW(dst); frame := anc.dsc;          WHILE (frame # NIL) & (frame.name # S.s) DO frame := frame.next END;          IF frame # NIL THEN dst.frame := frame ELSE PErr("frameref") END;          IF str.lastDst # NIL THEN str.lastDst.next := dst ELSE str.dst := dst END;          str.lastDst := dst; GetSym        END;        CheckTail(") DST")      ELSIF Matching(S.s, DspOp) THEN str.terminal := TRUE; GetSym;        IF (S.class = Int) OR (S.class = Real) THEN str.HPad := S.x; GetSym;          IF (S.class = Char) & (S.c = "@") THEN GetSym;            IF (S.class = Int) OR (S.class = Real) THEN str.VPad := S.x; GetSym              ELSE PErr("VPad")            END          ELSE str.VPad := str.HPad          END        END;        CheckTail(") DSP")      ELSE PErr("stream operation")      END    ELSE PErr("name")    END;    CheckTail(") STR")  END PStream;  PROCEDURE PDeclaration* (VAR dcl: Declaration);  BEGIN    NEW(dcl); COPY(S.s, dcl.name); GetSym;    IF S.class = Int THEN dcl.class := Int; dcl.i := S.i; GetSym      ELSIF S.class = Real THEN dcl.class := Real; dcl.x := S.x; GetSym      ELSIF S.class = String THEN dcl.class := String; COPY(S.s, dcl.s); GetSym      ELSIF S.class = Name THEN dcl.class := Name; COPY(S.s, dcl.s); GetSym      ELSIF (S.class = Head) & Matching(S.s, ObjOp) THEN dcl.class := Obj; PObj(dcl.obj)      ELSE PErr("dcl")    END;    CheckTail(") Declaration")  END PDeclaration;  PROCEDURE PObj* (VAR obj: Object);    VAR attr: Declaration;  BEGIN NEW(obj); GetSym;    IF S.class = Name THEN COPY(S.s, obj.gen); GetSym ELSE PErr("gen") END;    WHILE S.class = Head DO PDeclaration(attr);      IF obj.lastAttr # NIL THEN obj.lastAttr.next := attr ELSE obj.attr := attr END;      obj.lastAttr := attr    END;    CheckTail(") OBJ")  END PObj;  PROCEDURE PFrame* (anc: Frame; VAR frame: Frame);    VAR R, C, rep, i: INTEGER; size: REAL; dcl: Declaration; dsc: Frame; str: Stream;  BEGIN    NEW(frame); frame.anc := anc; GetSym;    IF S.class = Name THEN COPY(S.s, frame.name); GetSym END;    WHILE S.class = Head DO      IF Matching(S.s, PosOp) THEN GetSym;        IF S.class = Int THEN frame.R := SHORT(S.i); GetSym;          IF (S.class = Char) & (S.c = ":") THEN GetSym;            IF S.class = Int THEN frame.RSpan := SHORT(S.i); GetSym              ELSE PErr("row span")            END          END        ELSE PErr("R")        END;        IF (S.class = Char) & (S.c = "@") THEN GetSym ELSE PErr("@") END;        IF S.class = Int THEN frame.C := SHORT(S.i); GetSym;          IF (S.class = Char) & (S.c = ":") THEN GetSym;            IF S.class = Int THEN frame.CSpan := SHORT(S.i); GetSym              ELSE PErr("col span")            END          END        ELSE PErr("C")        END;        CheckTail(") POS")      ELSIF Matching(S.s, SizeOp) THEN GetSym;        IF (S.class = Int) OR (S.class = Real) THEN frame.W := S.x; GetSym;          IF (S.class = Char) & (S.c = "@") THEN GetSym;            IF (S.class = Int) OR (S.class = Real) THEN frame.H := S.x; GetSym              ELSE PErr("H")            END          ELSE frame.H := frame.W          END        ELSE PErr("W")        END;        CheckTail(") SIZE")      ELSIF Matching(S.s, GridOp) THEN GetSym; i:= 1;        WHILE S.class = Int DO rep := SHORT(S.i); GetSym;          IF (S.class = Char) & (S.c = ":") THEN GetSym;            IF (S.class = Int) OR (S.class = Real) THEN size := S.x ELSE size := 0 END;            GetSym;            IF (S.class = Char) & (S.c = "%") THEN size := -size/100; GetSym END          ELSE size := MinInt          END;          WHILE rep # 0 DO frame.RP[i] := size; INC(i); DEC(rep) END        END;        frame.eofRows := i;        IF (S.class = Char) & (S.c = "@") THEN GetSym ELSE PErr("@") END;        i := 1;        WHILE S.class = Int DO rep := SHORT(S.i); GetSym;          IF (S.class = Char) & (S.c = ":") THEN GetSym;            IF (S.class = Int) OR (S.class = Real) THEN size := S.x ELSE size := 0 END;            GetSym;            IF (S.class = Char) & (S.c = "%") THEN size := -size/100; GetSym END          ELSE size := MinInt          END;          WHILE rep # 0 DO frame.CP[i] := size; INC(i); DEC(rep) END        END;        frame.eofCols := i;        CheckTail(") GRID")      ELSIF Matching(S.s, BGOp) THEN GetSym;        IF (S.class = Name) OR (S.class = String) THEN COPY(S.s, frame.BGPName); GetSym          ELSE PErr("BGName")        END;        CheckTail(") BG")      ELSIF Matching(S.s, PadOp) THEN GetSym;        IF (S.class = Int) OR (S.class = Real) THEN frame.HPad := S.x; GetSym;          IF (S.class = Char) & (S.c = "@") THEN GetSym;            IF (S.class = Int) OR (S.class = Real) THEN frame.VPad := S.x; GetSym              ELSE PErr("VPad")            END          ELSE frame.VPad := frame.HPad          END        ELSE PErr("HPad")        END;        CheckTail(") PAD")      ELSIF Matching(S.s, BndOp) THEN GetSym;        IF (S.class = Int) OR (S.class = Real) THEN frame.HBnd := S.x; GetSym;          IF (S.class = Char) & (S.c = "@") THEN GetSym;            IF (S.class = Int) OR (S.class = Real) THEN frame.VBnd := S.x; GetSym              ELSE PErr("VBnd")            END          ELSE frame.VBnd := frame.HBnd          END        ELSE PErr("HBnd")        END;        CheckTail(") BND")      ELSIF Matching(S.s, SepOp) THEN GetSym;        IF (S.class = Int) OR (S.class = Real) THEN frame.HSep := S.x; GetSym;          IF (S.class = Char) & (S.c = "@") THEN GetSym;            IF (S.class = Int) OR (S.class = Real) THEN frame.VSep := S.x; GetSym              ELSE PErr("VSep")            END          ELSE frame.VSep := frame.HSep          END        ELSE PErr("HSep")        END;        CheckTail(") SEP")      ELSIF Matching(S.s, ObjOp) THEN PObj(frame.obj)      ELSIF Matching(S.s, FrameOp) THEN PFrame(frame, dsc);        IF frame.lastDsc # NIL THEN frame.lastDsc.next := dsc ELSE frame.dsc := dsc END;        frame.lastDsc := dsc      ELSIF Matching(S.s, StrDefOp) THEN PStream(frame, str);        str.pos := 0; str.scope := DefaultScope;        IF frame.lastStd # NIL THEN frame.lastStd.next := str ELSE frame.std := str END;        frame.lastStd := str      ELSIF Matching(S.s, StrImpOp) THEN PStream(frame, str);        IF frame.lastSti # NIL THEN frame.lastSti.next := str ELSE frame.sti := str END;        frame.lastSti := str      ELSE PDeclaration(dcl);        IF frame.lastDcl # NIL THEN frame.lastDcl.next := dcl ELSE frame.dcl := dcl END;        frame.lastDcl := dcl      END    END;    IF frame.eofRows <= 0 THEN frame.eofRows := 1; frame.RP[1] := -1 END;    IF frame.eofCols <= 0 THEN frame.eofCols := 1; frame.CP[1] := -1 END;    R := 1; C := 1; dsc := frame.dsc;    WHILE dsc # NIL DO      IF dsc.R <= 0 THEN dsc.R := R END;      IF dsc.C <= 0 THEN dsc.C := C END;      IF dsc.RSpan <= 0 THEN dsc.RSpan := 1 END;      IF dsc.CSpan <= 0 THEN dsc.CSpan := 1 END;      IF dsc.C + dsc.CSpan < frame.eofCols THEN R := dsc.R; C := dsc.C + dsc.CSpan        ELSE R := dsc.R + 1; C := 1      END;      dsc := dsc.next    END;    CheckTail(") FRAME")  END PFrame;  PROCEDURE PDoc (VAR doc: Document);    VAR frame: Frame; str: Stream; obj: Object;  BEGIN NEW(doc); GetSym;    IF S.class = Name THEN COPY(S.s, doc.name); GetSym END;    WHILE S.class = Head DO      IF Matching(S.s, FrameOp) THEN PFrame(doc, frame);        IF (frame.W = 0) & (frame.H = 0) & (frame.obj = NIL) THEN          NEW(obj); obj.gen := "PowerDoc.NewView";          frame.obj := obj; frame.W := SW; frame.H := SH;          IF doc.lastDsc # NIL THEN doc.lastDsc.next := frame ELSE doc.dsc := frame END;          doc.lastDsc := frame        ELSE PErr("page frame")        END      ELSIF Matching(S.s, StrDefOp) THEN PStream(doc, str);        IF doc.lastStd # NIL THEN doc.lastStd.next := str ELSE doc.std := str END;        doc.lastStd := str      ELSIF Matching(S.s, MetaOp) THEN GetSym;        IF S.class = String THEN COPY(S.s, doc.meta); GetSym; CheckTail("MET")          ELSE PErr("meta")        END      ELSE PErr("DocSpec")      END    END   END PDoc;(*** Display handling ***)  PROCEDURE Inside (XP, YP, X, Y, W, H: REAL): BOOLEAN;  BEGIN RETURN (XP >= X) & (YP >= Y) & (XP < X + W) & (YP < Y + H)  END Inside;  PROCEDURE HandleFiller (V: Objects.Object; VAR M: Objects.ObjMsg);  BEGIN    WITH V: Viewers.Viewer DO      IF M IS Display.ModifyMsg THEN        WITH M: Display.ModifyMsg DO          IF (M.F = V) & (M.id = Display.extend) THEN            Display.ReplConst(12 (*Display.BG*), V.X, M.Y, V.W, V.Y - M.Y, 0)          END        END      END    END  END HandleFiller;  PROCEDURE ToLocation (V: Viewers.Viewer; VAR M: Oberon.InputMsg);    VAR dsc: Display.Frame; X, Y: INTEGER;  BEGIN    X := M.X - V.X; Y := M.Y - (V.Y + V.H - 1); dsc := V.dsc;    WHILE (dsc # NIL) & ~Inside(X, Y, dsc.X, dsc.Y, dsc.W, dsc.H) DO dsc := dsc.next END;    IF dsc # NIL THEN M.x := V.X; M.y := V.Y + V.H - 1; M.dlink := V; dsc.handle(dsc, M) END  END ToLocation;  PROCEDURE OMToDescendants (V: Viewers.Viewer; VAR M: Objects.ObjMsg);    VAR dsc: Display.Frame;  BEGIN dsc := V.dsc;     WHILE dsc # NIL DO dsc.handle(dsc, M); dsc := dsc.next END  END OMToDescendants;  PROCEDURE FMToDescendants (V: Viewers.Viewer; VAR M: Display.FrameMsg);    VAR dsc: Display.Frame;  BEGIN dsc := V.dsc;    WHILE dsc # NIL DO      M.x := V.X; M.y := V.Y + V.H - 1; M.dlink := V; dsc.handle(dsc, M); dsc := dsc.next    END  END FMToDescendants;  PROCEDURE Copy (V: Viewer; VAR V1: Viewer);  BEGIN NEW(V1); V1.handle := V.handle; V1.frame := V.frame  END Copy;  PROCEDURE Consume (V: Viewers.Viewer; X, Y: INTEGER; F: Display.Frame);  BEGIN F.X := X; F.Y := Y; F.next := V.dsc; V.dsc := F  END Consume;  PROCEDURE Restore (V: Viewer);    VAR dsc: Display.Frame; MC: Display.ControlMsg; MD: Display.DisplayMsg;      str: Stream; dst: Destination; WR: WordReader;  BEGIN    Oberon.RemoveMarks(V.X, V.Y, V.W, V.H);    DBFrame(V.frame); dsc := V.dsc;    WHILE dsc # NIL DO      Objects.Stamp(MC); MC.id := Display.restore; MC.F := dsc; MC.res := -1;      MC.x := V.X; MC.y := V.Y + V.H - 1; MC.dlink := V; dsc.handle(dsc, MC);      Objects.Stamp(MD); MD.id := Display.full; MD.device := Display.screen; MD.F := dsc; MD.res := -1;      MD.x := V.X; MD.y := V.Y + V.H - 1; MD.dlink := V; dsc.handle(dsc, MD);      dsc := dsc.next    END;    DFFrame(V.frame);    str := V.frame.sti;    WHILE str # NIL DO      WR.text := str.text; WR.scope := str.scope;      Texts.OpenReader(WR, str.text, str.pos); ReadTextWord(WR);      dst := str.dst;      WHILE ~WR.eot & (dst # NIL) DO DFStream(str, dst.frame, WR); dst := dst.next END;      str := str.next    END  END Restore;(*** Frame Scope Support ***)  PROCEDURE Container* (scope: Frame): Frame;  BEGIN    WHILE scope.obj = NIL DO scope := scope.anc END;    RETURN scope  END Container;  PROCEDURE ThisFrame* (scope: Frame; VAR name: ARRAY OF CHAR): Frame;    VAR frame, dsc: Frame;  BEGIN frame := NIL;    WHILE (scope # NIL) & (frame = NIL) DO dsc := scope.dsc;      WHILE (dsc # NIL) & (frame = NIL) DO        IF dsc.name = name THEN frame := dsc END;        dsc := dsc.next      END;      scope := scope.anc    END;    RETURN frame  END ThisFrame;  PROCEDURE GetCarrier* (scope: Frame; VAR obj: Object);  BEGIN    IF scope.obj # NIL THEN scope.obj.next := obj; obj := scope.obj    ELSE scope := scope.dsc;      WHILE scope # NIL DO GetCarrier(scope, obj); scope := scope.next END    END  END GetCarrier;(*** Command Support ***)  PROCEDURE FlipMark*;  BEGIN Display.ReplConst(Display.FG, C.XW, C.YW, C.WW, 2, Display.invert)  END FlipMark;  PROCEDURE Release* (VAR keysum: SET);    VAR keys: SET; X, Y: INTEGER;  BEGIN keysum := {}; Input.Mouse(keys, X, Y);    WHILE keys # {} DO keysum := keysum + keys;  Input.Mouse(keys, X, Y) END  END Release;  PROCEDURE Apply*;    VAR keysum: SET; frame: Frame; obj: Object; attr: Declaration;  BEGIN    FlipMark; Release(keysum); FlipMark;    IF keysum # {0, 1, 2} THEN      IF S.class = Name THEN        frame := ThisFrame(C.frame, S.s);        IF (frame # NIL) & (frame.sti = NIL) THEN obj := NIL; GetCarrier(frame, obj);          IF obj # NIL THEN            WHILE S.class = Head DO GetSym; PDeclaration(attr); SetAttr(obj.obx, attr.name, attr) END;            Update(obj.obx)          END        END      END    END  END Apply;  PROCEDURE Replace*;    VAR keysum: SET; cont, old, new: Frame; obj: Object;      F: Display.Frame; MC: Display.ControlMsg; MD: Display.DisplayMsg;  BEGIN    FlipMark; Release(keysum); FlipMark;    IF keysum # {0, 1, 2} THEN GetSym;      IF S.class = Name THEN        old := ThisFrame(C.frame, S.s);        IF (old # NIL) & (old.sti = NIL) THEN obj := NIL; GetCarrier(old, obj);          IF obj = NIL THEN nofErr := 0; GetSym; PFrame(NIL, new);            IF (nofErr = 0) & (new.sti = NIL) THEN GetCarrier(new, obj);              new.W := old.W; new.H := old.H; GFrame(new);              IF nofErr = 0 THEN                cont := Container(old); new.X := old.X; new.Y := old.Y;                Oberon.RemoveMarks(INT(new.X), INT(new.Y), INT(new.W), INT(new.H));                CFrameW(new); CFrameH(new); LFrame(new); BFrame(cont, new); DBFrame(new);                 WHILE obj # NIL DO F := obj.obx(Display.Frame);                   Objects.Stamp(MC); MC.id := Display.restore; MC.F := F; MC.res := -1;                   MC.x := INT(cont.X); MC.y := INT(cont.Y + cont.H) - 2 (*!*); MC.dlink := NIL; F.handle(F, MC);                   Objects.Stamp(MD); MD.id := Display.full; MD.device := Display.screen; MD.F := F; MD.res := -1;                   MD.x := INT(cont.X); MD.y := INT(cont.Y + cont.H) - 2 (*!*); MD.dlink := NIL; F.handle(F, MD);                   obj := obj.next                 END;                 DFFrame(new);                 new.anc := old.anc; new.next := old.next; old^ := new^               END             END           END        END      END    END  END Replace;  PROCEDURE Pop*;    VAR keysum: SET; frame: Frame; M: Oberon.InputMsg;  BEGIN    nofErr := 0; GetSym; PFrame(NIL, frame);    IF nofErr = 0 THEN GFrame(frame);      IF nofErr = 0 THEN        IF (frame.W = 0) & (frame.BGP # NIL) THEN frame.W := frame.BGP.width END;        IF (frame.H = 0) & (frame.BGP # NIL) THEN frame.H := frame.BGP.height END;        CFrameW(frame); CFrameH(frame); LFrame(frame); BFrame(NIL, frame);        Oberon.RemoveMarks(INT(frame.X), INT(frame.Y), INT(frame.W), INT(frame.H));        Display.CopyBlock(C.X, C.Y, INT(frame.W), INT(frame.H), 0, Display.UBottom, Display.replace);        frame.X := C.X; frame.Y := C.Y; DBFrame(frame); DFFrame(frame);        Release(keysum);         Display.CopyBlock(0, Display.UBottom, INT(frame.W), INT(frame.H), INT(frame.X), INT(frame.Y), Display.replace)      END    END  END Pop;  PROCEDURE Overlay*;    VAR keysum: SET; frame: Frame; obj: Object; VP: Viewer; VF: Viewers.Viewer;  BEGIN    FlipMark; Release(keysum); FlipMark;    IF keysum # {0, 1, 2} THEN       nofErr := 0; GetSym; PFrame(C.doc, frame);      IF (frame.W = 0) & (frame.H = 0) & (frame.obj = NIL) THEN        NEW(obj); obj.gen := "PowerDoc.NewView";        frame.obj := obj; frame.W := SW; frame .H := SH;      ELSE PErr("page frame")      END;      IF nofErr = 0 THEN GFrame(frame);        IF nofErr = 0 THEN CFrameW(frame); CFrameH(frame); LFrame(frame); BFrame(NIL, frame);          VP := frame.obj.obx(Viewer);          VP.doc := C.doc; VP.frame := frame; VP.isOverlay := TRUE; C.doc.view := VP;          NEW(VF); VF.handle := HandleFiller; Viewers.OpenTrack(0, VP.W-1, VF);          Viewers.Open(VP, 0, SH-1); Restore(VP)        END      END    END  END Overlay;  PROCEDURE Flip*;    VAR keysum: SET; old, new: Frame; VP: Viewer; VF: Viewers.Viewer;  BEGIN    FlipMark; Release(keysum); FlipMark;    IF keysum # {0, 1, 2} THEN       old := C.doc.view.frame; GetSym;      IF S.class = Name THEN new := C.doc.dsc;        WHILE (new # NIL) & (new.name # S.s) DO new := new.next END      ELSE new := old.next      END;      IF new = NIL THEN new := C.doc.dsc END;      IF new # old THEN        Viewers.Close(old.obj.obx(Viewer));        VP := new.obj.obx(Viewer); VP.doc := C.doc; VP.frame := new; C.doc.view := VP;        NEW(VF); VF.handle := HandleFiller; Viewers.OpenTrack(0, VP.W-1, VF);        Viewers.Open(VP, 0, SH-1); Restore(VP)      END    END  END Flip;(*** Compiler & Renderer ***)  PROCEDURE ParseStream (VAR M: Oberon.InputMsg; doc: Document; frame: Frame; str: Stream);    VAR WR: WordReader; ref: RefPoint; obx: Objects.Object;      Mod: Modules.Module; Proc: Modules.Command;      keysum: SET; XW, WW, SW: REAL; pos, len: LONGINT; i, j: INTEGER;      name: ARRAY 32 OF CHAR;  BEGIN    IF str.terminal & Inside(M.X, M.Y, frame.X + str.HPad, frame.Y + str.VPad, frame.W - 2*str.HPad, frame.H- 2*str.VPad) THEN      ref := str.ref;      WHILE (ref # NIL) & (M.Y < ref.Y) DO ref := ref.next END;      IF ref # NIL THEN        Oberon.DrawCursor(Oberon.Mouse, Oberon.Arrow, M.X, M.Y);        WR.text := str.text; WR.scope := ref.scope;        Texts.OpenReader(WR, str.text, ref.pos); ReadTextWord(WR);        pos := ref.pos; XW := frame.X + str.HPad;        LOOP          len := WR.len; WW := WR.wid;          IF WR.eot OR (XW + WW > M.X) THEN EXIT END;          WR.lib.GetObj(WR.lib, ORD(" "), obx); SW := obx(Fonts.Char).dx; ReadTextWord(WR);          IF (WR.len = 2) & (WR.str[0] = "%") & (WR.str[1] = "\") OR (XW + WW + WR.wid >= frame.X + frame.W - str.HPad)            THEN EXIT          END;          pos := pos + len + 1; XW := XW + WW + SW        END;        IF WR.scope.com # 0 THEN          Texts.OpenScanner(S, WR.text, WR.scope.com); Texts.Scan(S);          COPY(S.s, name); i := 0; j := 0;          WHILE name[j] # 0X DO            IF name[j] = "." THEN i := j END;            INC(j)          END;          IF i > 0 THEN name[i] := 0X;            Mod := Modules.ThisMod(name);            IF Modules.res = 0 THEN INC(i); j := i;              WHILE name[j] # 0X DO name[j - i] := name[j]; INC(j) END;              name[j - i] := 0X;              Proc := Modules.ThisCommand(Mod, name);              IF Modules.res = 0 THEN                C.doc := doc; C.frame := frame; C.text := WR.text; C.pos := Texts.Pos(S);                C.keys := M.keys; C.X := M.X; C.Y := M.Y;                C.XW := INT(XW); C.YW := INT(ref.Y); C.WW := INT(WW);                Proc              END            END          END        ELSE Release(keysum)        END;        M.res := 0      END    END  END ParseStream;  PROCEDURE HandleCmd (VAR M: Oberon.InputMsg; doc: Document; frame: Frame);    VAR dsc: Frame; str: Stream;  BEGIN    IF Inside(M.X, M.Y, frame.X, frame.Y, frame.W, frame.H) THEN dsc := frame.dsc;      WHILE (M.res < 0) & (dsc # NIL) DO HandleCmd(M, doc, dsc); dsc := dsc.next END;      IF M.res < 0 THEN str := frame.std;        WHILE (M.res < 0) & (str # NIL) DO ParseStream(M, doc, frame, str); str := str.next END;        IF M.res < 0 THEN str := frame.sti;          WHILE (M.res < 0) & (str # NIL) DO ParseStream(M, doc, frame, str); str := str.next END        END      END    END  END HandleCmd;  PROCEDURE HandleViewer (V: Objects.Object; VAR M: Objects.ObjMsg);    VAR V1: Viewer; dsc: Display.Frame;  BEGIN    WITH V: Viewer DO      IF M IS Display.FrameMsg THEN        WITH M: Display.FrameMsg DO          IF M IS Oberon.InputMsg THEN            WITH M: Oberon.InputMsg DO              IF M.id = Oberon.track THEN ToLocation(V, M);                IF M.res < 0 THEN Oberon.DrawCursor(Oberon.Mouse, Oberon.Arrow, M.X, M.Y);                  IF M.keys # {} THEN HandleCmd(M, V.doc, V.frame);                    IF M.res < 0 THEN                      REPEAT Input.Mouse(M.keys, M.X, M.y); Oberon.DrawCursor(Oberon.Mouse, Oberon.Arrow, M.X, M.Y)                      UNTIL M.keys = {}                    END                  END                END              ELSE OMToDescendants(V, M)              END            END          ELSIF M IS Oberon.ControlMsg THEN            WITH M: Oberon.ControlMsg DO              IF M.id = Oberon.mark THEN                IF Inside(M.X, M.Y, V.X, V.Y, V.W, V.H) THEN                  Oberon.DrawCursor(Oberon.Mouse, Oberon.Arrow, M.X, M.Y);                  Oberon.DrawCursor(Oberon.Pointer, Oberon.Star, M.X, M.Y)                END              ELSIF M.id = Oberon.neutralize THEN                IF V.isOverlay THEN Viewers.Close(V) END              ELSE FMToDescendants(V, M)              END            END          ELSIF M IS Display.LocateMsg THEN            WITH M: Display.LocateMsg DO              IF M.F = NIL THEN FMToDescendants(V, M) END            END          ELSIF M IS Display.ModifyMsg THEN            WITH M: Display.ModifyMsg DO              IF M.F # V THEN dsc := V.dsc;                WHILE (dsc # NIL) & (dsc # M.F) DO dsc := dsc.next END;                IF M.F # dsc THEN FMToDescendants(V, M) END              END            END          ELSIF M IS Display.ConsumeMsg THEN            WITH M: Display.ConsumeMsg DO              IF M.F = V THEN                IF (M.id = Display.drop) & (M.obj # NIL) & (M.obj IS Display.Frame) THEN                  Consume(V, M.u, M.v, M.obj(Display.Frame))                END              ELSE FMToDescendants(V, M)              END            END          ELSIF M IS Display.ControlMsg THEN            WITH M: Display.ControlMsg DO              IF (M.F = NIL) OR (M.F = V) THEN                IF M.id = Display.restore THEN Restore(V)                  ELSIF M.id = Display.suspend THEN                  ELSE FMToDescendants(V, M)                END              ELSE FMToDescendants(V, M)              END            END          ELSE FMToDescendants(V, M)          END        END      ELSIF M IS Objects.CopyMsg THEN         WITH M: Objects.CopyMsg DO Copy(V, V1); M.obj := V1 END      ELSIF M IS Objects.AttrMsg THEN        WITH M: Objects.AttrMsg DO          IF (M.id = Objects.get) & (M.name = "Locked") THEN            M.res := 0; M.class := Objects.Bool; M.b := TRUE          END        END      ELSE OMToDescendants(V, M)      END    END  END HandleViewer;  PROCEDURE Compile*;    VAR doc: Document; libCont, frame: Frame; str: Stream;      i: INTEGER; L: Objects.Library; libName: ARRAY 32 OF CHAR;  BEGIN    Texts.OpenScanner(S, Oberon.Par.text, Oberon.Par.pos); GetSym;    WHILE S.class = Head DO      IF Matching(S.s, LibOp) THEN GetSym;        IF S.class = Name THEN          COPY(S.s, libName); libCont := NIL; nofErr := 0; GetSym;          WHILE (nofErr = 0) & (S.class = Head) & Matching(S.s, FrameOp) DO PFrame(NIL, frame);            IF (frame.name[0] # 0X) & (frame.obj # NIL) THEN frame.next := libCont; libCont := frame              ELSE PErr("named object")            END          END;          IF nofErr = 0 THEN frame := libCont;            WHILE (nofErr = 0) & (frame # NIL) DO GFrame(frame); frame := frame.next END;            IF nofErr = 0 THEN              L := Objects.ThisLibrary(libName); frame := libCont;              WHILE frame # NIL DO                CFrameW(frame); CFrameH(frame); LFrame(frame); BFrame(NIL, frame); BindObj(frame.obj.obx, L);                Objects.PutName(L.dict, frame.obj.obx.ref, frame.name);                frame := frame.next              END;              L.Store(L)            END          END        ELSE PErr("libname")        END      ELSIF  Matching(S.s, DocOp) THEN PDoc(doc);        IF (nofErr = 0) & (doc.dsc # NIL) & (doc.name[0] # 0X) THEN frame := doc.dsc;          WHILE (nofErr = 0) & (frame # NIL) DO GFrame(frame); frame := frame.next END;          IF nofErr = 0 THEN str := doc.std;            WHILE (nofErr = 0) & (str # NIL) DO GStream(str); str := str.next END;            IF nofErr = 0 THEN              COPY(doc.name, libName); i := 0;              REPEAT INC(i) UNTIL libName[i] = 0X;              libName[i] := "."; libName[i+1] := "L"; libName[i+2] := "i"; libName[i+3] := "b"; libName[i+4] := 0X;              L := Objects.ThisLibrary(libName); frame := doc.dsc;              WHILE frame # NIL DO                CFrameW(frame); CFrameH(frame); LFrame(frame); BFrame(NIL, frame); BindObj(frame.obj.obx, L);                frame := frame.next              END;              L.Store(L)            END          END        END      END    END  END Compile;  PROCEDURE Open*;    VAR doc: Document; dsc: Frame; str: Stream; dst: Destination;      WR: WordReader; VF: Viewers.Viewer; VP: Viewer;  BEGIN    Texts.OpenScanner(S, Oberon.Par.text, Oberon.Par.pos); GetSym;    IF (S.class = Head) & Matching(S.s, DocOp) THEN nofErr := 0; PDoc(doc);      IF (nofErr = 0) & (doc.dsc # NIL) THEN dsc := doc.dsc;        WHILE (nofErr = 0) & (dsc # NIL) DO GFrame(dsc); dsc := dsc.next END;        IF nofErr = 0 THEN str := doc.std;          WHILE (nofErr = 0) & (str # NIL) DO GStream(str); str := str.next END;          IF nofErr = 0 THEN dsc := doc.dsc;            WHILE dsc # NIL DO              CFrameW(dsc); CFrameH(dsc); LFrame(dsc); BFrame(NIL, dsc); dsc := dsc.next            END;            str := doc.std;            WHILE str # NIL DO              WR.text := str.text; WR.pos := str.pos; WR.scope := DefaultScope;              Texts.OpenReader(WR, str.text, str.pos); ReadTextWord(WR); dst := str.dst;              WHILE ~WR.eot & (dst # NIL) DO LStream(str, dst.frame, WR); dst := dst.next END;              str := str.next            END;            VP := doc.dsc.obj.obx(Viewer); VP.doc := doc; VP.frame := doc.dsc; doc.view := VP;            NEW(VF); VF.handle := HandleFiller; Viewers.OpenTrack(0, VP.W-1, VF);            Viewers.Open(VP, 0, SH-1); Restore(VP)          END        END      END    END  END Open;(*** Resource Linker ***)  PROCEDURE EQ (VAR name: ARRAY OF CHAR; VAR i: INTEGER): BOOLEAN;    VAR j: INTEGER;  BEGIN j := 0;    WHILE (res[i] # 0X) & (name[j] # 0X) & (res[i] = name[j]) DO INC(i); INC(j) END;    RETURN res[i] = name[j]  END EQ;  PROCEDURE AddResource (VAR name: ARRAY OF CHAR);    VAR i, j: INTEGER;  BEGIN j := 0;    WHILE (name[j] # 0X) & (name[j] # ".") DO INC(j) END;    name[j] := 0X; i := 0;    WHILE (i # ind) & ~EQ(name, i) DO      WHILE res[i] # 0X DO INC(i) END;      INC(i)    END;    IF i = ind THEN j := 0;      WHILE name[j] # 0X DO res[ind] := name[j]; INC(ind); INC(j) END;      res[ind] := 0X; INC(ind)    END  END AddResource;  PROCEDURE ReadWord0 (VAR WR: WordReader);    VAR i: INTEGER; ch: CHAR;   BEGIN Texts.Read(WR, ch);    WHILE ~WR.eot & (ch <= " ") DO Texts.Read(WR, ch) END;    i := 0;    WHILE ~WR.eot & (ch > " ") & (i # MaxLen) DO      WR.str[i] := ch; INC(i); Texts.Read(WR, ch)    END;    WR.len := i; WR.nextCh := ch  END ReadWord0;  PROCEDURE ReadTextWord0 (VAR WR: WordReader);    VAR pos: LONGINT; pbal: INTEGER; ch: CHAR;  BEGIN ReadWord0(WR);    IF WR.len = 2 THEN      IF (WR.str[0] = "{") & (WR.str[1] = "%") THEN pos := Texts.Pos(WR);        Texts.OpenScanner(S, WR.text, pos); GetSym;        LOOP          IF S.class # Head THEN EXIT END;          IF Matching(S.s, FontOp) THEN GetSym;            IF S.class = Name THEN AddResource(S.s); GetSym (*tail*) END           ELSIF Matching(S.s, ColOp) THEN GetSym;            IF S.class = Int THEN GetSym END          ELSIF Matching(S.s, ParOp) THEN GetSym;            IF S.class = Int THEN GetSym END          ELSIF Matching(S.s, LeadOp) THEN GetSym;            IF S.class = Int THEN GetSym END          ELSIF Matching(S.s, CmdOp) THEN GetSym;            IF S.class = Name THEN AddResource(S.s); pbal := 1;               REPEAT Texts.Scan(S);                IF S.class = Char THEN                  IF S.c = "(" THEN INC(pbal) ELSIF S.c = ")" THEN DEC(pbal) END                END              UNTIL pbal = 0            END          END;          pos := Texts.Pos(S); (*pos after tail*) GetSym        END;        Texts.OpenReader(WR, WR.text, pos); ReadTextWord0(WR)      ELSIF (WR.str[0] = "%") & (WR.str[1] = "}") THEN ReadTextWord0(WR)      END    END  END ReadTextWord0;  PROCEDURE AddStreamResources (str: Stream);    VAR WR: WordReader;  BEGIN WR.text := str.text;    Texts.OpenReader(WR, str.text, str.pos);    REPEAT ReadTextWord0(WR) UNTIL WR.eot  END AddStreamResources;  PROCEDURE AddFrameResources (frame: Frame);    VAR dsc: Frame; str: Stream; obx: Objects.Object; M: Objects.AttrMsg;  BEGIN    IF frame.obj # NIL THEN obx := frame.obj.obx; M.id := Objects.get;      M.name := "Gen"; obx.handle(obx, M);      IF (M.res = 0) & (M.class = Objects.String) THEN AddResource(M.s) END;      M.name := "Cmd"; obx.handle(obx, M);      IF (M.res = 0) & (M.class = Objects.String) THEN AddResource(M.s) END    END;    str := frame.std;    WHILE str # NIL DO AddStreamResources(str); str := str.next END;    dsc := frame.dsc;    WHILE dsc # NIL DO AddFrameResources(dsc); dsc := dsc.next END  END AddFrameResources;  PROCEDURE Link*;    VAR doc: Document; dsc: Frame; str: Stream; i: INTEGER;  BEGIN    Texts.OpenScanner(S, Oberon.Par.text, Oberon.Par.pos); GetSym;    IF (S.class = Head) & Matching(S.s, DocOp) THEN nofErr := 0; PDoc(doc);      IF (nofErr = 0) & (doc.dsc # NIL) THEN dsc := doc.dsc;        WHILE (nofErr = 0) & (dsc # NIL) DO GFrame(dsc); dsc := dsc.next END;        IF nofErr = 0 THEN str := doc.std;          WHILE (nofErr = 0) & (str # NIL) DO GStream(str); str := str.next END;          IF nofErr = 0 THEN ind := 0; dsc := doc.dsc;            WHILE dsc # NIL DO AddFrameResources(dsc); dsc := dsc.next END;            str := doc.std;            WHILE str # NIL DO AddStreamResources(str); str := str.next END          END        END      END    END;    i := 0;    WHILE i # ind DO      WHILE res[i] # 0X DO Out.Char(res[i]); INC(i) END;      Out.Ln; INC(i)    END  END Link;  PROCEDURE NewView*;    VAR V: Viewer;  BEGIN NEW(V); V.handle := HandleViewer; Objects.NewObj := V  END NewView;BEGIN  NEW(DefaultScope); DefaultScope.lead := 0;  DefaultScope.lib := Fonts.Default; DefaultScope.col := Display.FG; DefaultScope.voff := 0;  SW := Display.Width DIV 8 * 5; SH := Display.Height;  BoxPat[0] := {0..11};   BoxPat[1] := {0, 11}; BoxPat[2] := {0, 11}; BoxPat[3] := {0, 11}; BoxPat[4] := {0, 11};  BoxPat[5] := {0, 11}; BoxPat[6] := {0, 11}; BoxPat[7] := {0, 11}; BoxPat[8] := {0, 11};  BoxPat[9] := {0, 11}; BoxPat[10] := {0, 11}; BoxPat[11] := {0.. 11};  NEW(box);  box.dx := 12; box.x := 0; box.y := -3; box.w := 12; box.h := 12;  box.pat := Display.NewPattern(12, 12, BoxPat);  LibOp := "LIB"; DocOp := "DOC"; MetaOp := "MET"; FrameOp := "FRA"; ObjOp := "OBJ";  StrDefOp := "STD"; StrImpOp := "STI"; DstOp := "DST"; DspOp := "DSP"; PosOp := "POS"; SizeOp := "SIZ";  BGOp := "BG"; GridOp := "GRI"; ParOp := "PAR"; PadOp := "PAD"; BndOp := "BND"; SepOp:= "SEP";  FontOp := "FON"; ColOp := "COL"; LeadOp := "LEA"; ImpOp := "IMP"; CmdOp := "COM"END PowerDoc.