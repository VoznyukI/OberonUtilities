(* ETH Oberon, Copyright 1990-2003 Computer Systems Institute, ETH Zurich, CH-8092 Zurich.Refer to the license.txt file provided with this distribution. *)MODULE LayoutPanels0;		IMPORT		Objects, Gadgets, Display, Display3, Effects, Texts, Oberon;		CONST							(* format *)		left = 0; right = 1; bottom = 2; top = 3;	(* for elements *)		meleft = 12; meright = 13; mebottom = 14; metop = 15;	(* default *)		samewidth = 4; sameheight = 5;		hstatic = 6; vstatic = 7;		innerleft = 8; innerright = 9; innerbottom = 10; innertop = 11;	(* for tables *)					TYPE		Element* = POINTER TO ElementDesc;		ElementDesc* = RECORD (Gadgets.FrameDesc)			format*: SET;			hfactor*, vfactor*, row*, col*, minx*, miny*, minw*, minh*: INTEGER;			size*: PROCEDURE (e: Element);			make*: PROCEDURE (e: Element; x, y, w, h: INTEGER)		END;				Container* = POINTER TO ContainerDesc;		ContainerDesc* = RECORD (ElementDesc)			hborder*, vborder*: INTEGER		END;				IntArray = POINTER TO ARRAY OF INTEGER;		Table* = POINTER TO TableDesc;		TableDesc* = RECORD (ContainerDesc)			cols*, rows*, hdist*, vdist*, hfill*, vfill*: INTEGER;			gmaxw*, gmaxh*, hexpand*, vexpand*, hoffset*, voffset*: IntArray		END;				PanelMsg* = RECORD (Display.FrameMsg) sender, panel*: Gadgets.Frame END;		ContainerMsg* = RECORD (Display.FrameMsg) sender, container*: Gadgets.Frame END;		CalcMsg* = RECORD (Objects.ObjMsg) END;		ConsumeMsg* = RECORD (Display.ConsumeMsg) e*: Element END;						VAR		head: Element;	(* dummy *)		W: Texts.Writer;	PROCEDURE ^ NewElement* (): Element;	PROCEDURE ^ NewContainer* (): Container;	PROCEDURE ^ NewTable* (): Table;	PROCEDURE ^ EmptyTable* (rows, cols: INTEGER): Table;	(* --- *)		(* send Display.DisplayMsg with area (u, v, w, h) to receiver *)	PROCEDURE DisplayArea (receiver: Display.Frame; u, v, w, h: INTEGER);		VAR M: Display.DisplayMsg;	BEGIN		M.F := receiver; (* x, y, res set by Broadcast *)		M.device := Display.screen; M.id := Display.area;		M.u := u; M.v := v; M.w := w; M.h := h;		Display.Broadcast(M)	END DisplayArea;		(* see LayoutPanels.Mod *)	PROCEDURE ClipAgainst(VAR x, y, w, h: INTEGER; x1, y1, w1, h1: INTEGER);	VAR r, t, r1, t1: INTEGER;	BEGIN		r := x + w - 1; r1 := x1 + w1 - 1; t := y + h - 1; t1 := y1 + h1 - 1;		IF x < x1 THEN x := x1 END;		IF y < y1 THEN y := y1 END;		IF r > r1 THEN r := r1 END;		IF t > t1 THEN t := t1 END;		w := r - x + 1; h := t - y + 1;	END ClipAgainst;		(* similar to ToChildren() in LayoutPanels.Mod *)	PROCEDURE SimpleToElements (F: Container; VAR M: Display.FrameMsg);		VAR Mdlink, Fdlink: Objects.Object; f: Display.Frame;	BEGIN		Fdlink := F.dlink; Mdlink := M.dlink; 		F.dlink := M.dlink; M.dlink := F;		f := F.dsc;		WHILE f # NIL DO f.handle(f, M); f := f.next END;		F.dlink := Fdlink; M.dlink := Mdlink	END SimpleToElements;		(* --- *)	(** get the container of Element sender, will return NIL if sender is top Element of panel *)	PROCEDURE GetContainer* (sender: Element): Container;		VAR M: ContainerMsg;	BEGIN		M.dlink := NIL; M.F := NIL;		M.sender := sender; M.container := NIL; Display.Broadcast(M);		IF (M.container # NIL) & (M.container IS Container) THEN RETURN M.container(Container) ELSE RETURN NIL END	END GetContainer;		(** returns the panel which holds this element *)	PROCEDURE GetPanel* (sender: Element): Gadgets.Frame;		VAR M: PanelMsg;	BEGIN		M.dlink := NIL; M.F := NIL;		M.sender := sender; M.panel := NIL; Display.Broadcast(M);		RETURN M.panel	END GetPanel;	PROCEDURE DummyHandler (obj: Objects.Object; VAR M: Objects.ObjMsg);	BEGIN	END DummyHandler;		PROCEDURE Drop* (obj: Objects.Object; dest: Display.Frame; u, v: INTEGER);		VAR C: ConsumeMsg; C0: Display.ConsumeMsg; dummy: Objects.Object;	BEGIN		IF obj # NIL THEN			IF obj IS Element THEN				C.id := Display.drop; C.F := dest; C.u := u; C.v := v;				IF obj(Element).obj = NIL THEN NEW(dummy); dummy.handle := DummyHandler;					C.obj := dummy				ELSE C.obj := obj(Element).obj				END;				C.e := obj(Element);				Display.Broadcast(C)			ELSE				C0.id := Display.drop; C0.F := dest; C0.u := u; C0.v := v; C0.obj := obj;				Display.Broadcast(C0)			END;		END	END Drop;		(** similar to Gadgets.Integrate *)	PROCEDURE Integrate* (obj: Objects.Object);		VAR C: ConsumeMsg; dummy: Objects.Object;	BEGIN		IF obj # NIL THEN 			IF obj IS Element THEN			 	C.id := Display.integrate;  C.F := NIL;				IF obj(Element).obj = NIL THEN NEW(dummy); dummy.handle := DummyHandler;					C.obj := dummy				ELSE C.obj := obj(Element).obj				END;				C.e := obj(Element);				Display.Broadcast(C)			ELSE				Gadgets.Integrate(obj)			END		END	END Integrate;	(* --- *)		PROCEDURE CalcPanelOf (e: Element);	VAR p: Gadgets.Frame; M: CalcMsg;	BEGIN p := GetPanel(e); IF p # NIL THEN p.handle(p, M) END	(* should be always the case *)	END CalcPanelOf;	(* --- *)		(** returns the element which has obj as model, e is the tree to search in, obj # NIL *)	PROCEDURE GetElementOf* (obj: Objects.Object; e: Element): Element;		VAR f: Display.Frame;	BEGIN		IF e.obj = obj THEN RETURN e		ELSIF e IS Container THEN f := e.dsc; e := NIL;			WHILE (f # NIL) & (e = NIL) DO e := GetElementOf(obj, f(Element)); f := f.next END;			RETURN e		ELSE RETURN NIL		END	END GetElementOf;		(* --- Edit procedures --- *)	(* Note: M.id is ignored by Elements (always deep), but not by Leaf-Gadgets *)	PROCEDURE CopyElements* (f: Display.Frame): Display.Frame;		VAR M: Objects.CopyMsg;	BEGIN M.id := Objects.deep; M.obj := NIL; M.dlink := NIL; Objects.Stamp(M); f.handle(f, M); RETURN M.obj(Display.Frame)	END CopyElements;	(* call with list := LinkGadgets(e, list) *)	(* link not VAR paramter because NIL can't be VAR parameter *)	PROCEDURE LinkGadgets* (e: Element; link: Display.Frame): Display.Frame;		VAR f: Display.Frame;	BEGIN		IF e IS Container THEN f := e.dsc;			WHILE f # NIL DO link := LinkGadgets(f(Element), link); f := f.next END		ELSE (* leaf element *)			IF (e.obj # NIL) & (e.obj IS Display.Frame) THEN e.obj.slink := link; link := e.obj(Display.Frame) END		END;		RETURN link	END LinkGadgets;		(* removes objlist from Panel p *)	PROCEDURE KillFrames (p: Objects.Object; objlist: Display.Frame);		VAR M: Display.ControlMsg;	BEGIN IF objlist # NIL THEN M.F := objlist; (* x, y undef *) M.res := -1; M.id := Display.remove; p.handle(p, M) END	END KillFrames;	(* renumbers Elements of Table t *)	PROCEDURE SetRowCol (t: Table);		VAR i, j: INTEGER; f: Display.Frame;	BEGIN f := t.dsc;		FOR i := 0 TO t.rows - 1 DO			FOR j := 0 TO t.cols - 1 DO				f(Element).row := i; f(Element).col := j; f := f.next			END		END	END SetRowCol;	(** inserts e after e0, e0 # NIL, e # NIL *)	PROCEDURE InsertElementAfter* (e0, e: Element);	BEGIN e.next := e0.next; e0.next := e	END InsertElementAfter;		(** inserts a row at position y in Table tab *)	PROCEDURE InsertRow* (tab: Table; y: INTEGER; recalc: BOOLEAN);		VAR i: INTEGER; f: Display.Frame;	BEGIN		head.next := tab.dsc; (* dummy head *)		f := head;		IF y < 0 THEN y := 0 ELSIF y > tab.rows THEN y := tab.rows END;				(* insert new elements *)		FOR i := 0 TO y*tab.cols - 1 DO f := f.next END;	(* find pos *)		FOR i := 0 TO tab.cols - 1 DO			InsertElementAfter(f(Element), NewElement());			f.next(Element).hfactor := 1; f.next(Element).vfactor := 1		END;		tab.dsc := head.next;		INC(tab.rows); 		SetRowCol(tab); (* correct row, col address *)		NEW(tab.gmaxh, tab.rows); NEW(tab.vexpand, tab.rows); NEW(tab.voffset, tab.rows + 1);		IF recalc THEN CalcPanelOf(tab) END	END InsertRow;	(** inserts col at position x in Table tab *)	PROCEDURE InsertCol* (tab: Table; x: INTEGER; recalc: BOOLEAN);	VAR i, j: INTEGER; f: Display.Frame;	BEGIN		head.next := tab.dsc; (* dummy head *)		f := head;		IF x < 0 THEN x := 0 ELSIF x > tab.cols THEN x := tab.cols END;		FOR i := 0 TO tab.rows - 1 DO			FOR j := 0 TO x - 1 DO f := f.next END;			InsertElementAfter(f(Element), NewElement()); f := f.next;			WITH f: Element DO f.hfactor := 1; f.vfactor := 1 END;			FOR j := x TO tab.cols - 1 DO f := f.next END		END;		tab.dsc := head.next;		INC(tab.cols);		SetRowCol(tab);		NEW(tab.gmaxw, tab.cols); NEW(tab.hexpand, tab.cols); NEW(tab.hoffset, tab.cols + 1);		IF recalc THEN CalcPanelOf(tab) END	END InsertCol;	(** removes row at position y in Table tab *)	PROCEDURE RemoveRow* (tab: Table; y: INTEGER; recalc: BOOLEAN);		VAR i: INTEGER; f, objlist: Display.Frame; p: Objects.Object; CM: CalcMsg;	BEGIN		IF tab.rows > 1 THEN head.next := tab.dsc; f := head; (* dummy head *)			objlist := NIL;			FOR i := 0 TO y*tab.cols - 1 DO f := f.next END;	(* find pos *)			FOR i := 0 TO tab.cols - 1 DO 				objlist := LinkGadgets(f.next(Element), objlist);				f.next := f.next.next			END;			tab.dsc := head.next;			DEC(tab.rows);			SetRowCol(tab);			(* no reallocation in case of fewer rows! *)						p := GetPanel(tab);			IF p # NIL THEN				KillFrames(p, objlist);				IF recalc THEN p.handle(p, CM) END			END		END	END RemoveRow;	(** removes col at position x in Table tab *)	PROCEDURE RemoveCol* (tab: Table; x: INTEGER; recalc: BOOLEAN);		VAR i, j: INTEGER; f, objlist: Display.Frame; p: Objects.Object; CM: CalcMsg;	BEGIN		IF tab.cols > 1 THEN head.next := tab.dsc; f := head; (* dummy head *)			objlist := NIL;			FOR i := 0 TO tab.rows - 1 DO				FOR j := 0 TO x - 1 DO f := f.next END;				objlist := LinkGadgets(f.next(Element), objlist);				f.next := f.next.next;				FOR j := x + 1 TO tab.cols - 1 DO f := f.next END			END;			tab.dsc := head.next;			DEC(tab.cols);			SetRowCol(tab);			(* no reallocation in case of fewer rows! *)						p := GetPanel(tab);			IF p # NIL THEN				KillFrames(p, objlist);				IF recalc THEN p.handle(p, CM) END			END		END	END RemoveCol;		(* --- *)		(** links obj as model for Element e *)	PROCEDURE InsertGadget* (e: Element; obj: Gadgets.Frame);		VAR M: Objects.AttrMsg;	BEGIN		EXCL(obj(Gadgets.Frame).state, Gadgets.selected);		e.obj := obj(Gadgets.Frame);				M.id := Objects.get; M.name := "minw"; M.res := -1; obj.handle(obj, M);		IF (M.res >= 0) & (M.class = Objects.Int) & (M.i >= 0) THEN e.minw := SHORT(M.i) ELSE e.minw := obj.W END;		M.id := Objects.get; M.name := "minh"; M.res := -1; obj.handle(obj, M);		IF (M.res >= 0) & (M.class = Objects.Int) & (M.i >= 0) THEN e.minh := SHORT(M.i) ELSE e.minh := obj.H END	END InsertGadget;		(** inserts Element e into Place Container c *)	PROCEDURE InsertPlaceElement* (c: Container; e: Element);	BEGIN head.next := c.dsc; InsertElementAfter(head, e); c.dsc := head.next	END InsertPlaceElement;			(** replaces e0 in c with e1. c, e0, e1 # NIL *)	PROCEDURE ReplaceElement* (c: Container; e0, e1: Element; recalc: BOOLEAN);		VAR f: Display.Frame;	BEGIN		head.next := c.dsc; f := head;		WHILE (f.next # NIL) & (f.next # e0) DO f := f.next END;		IF f.next # NIL THEN	(* found *)			e1.next := e0.next; e0.next := NIL; f.next := e1; c.dsc := head.next;			IF c IS Table THEN SetRowCol(c(Table)) END;			IF recalc THEN CalcPanelOf(c) END		END	END ReplaceElement;		(**		container of e IS Table: replaces Element by a virtual Element		container of e IS Place: removes Element from Container		e # NIL	*)	PROCEDURE ClearElement* (e: Element; VAR objlist: Display.Frame): BOOLEAN;		VAR c: Container; new: Element; f: Display.Frame;	BEGIN c := GetContainer(e);		IF c # NIL THEN			IF c IS Table THEN				new := NewElement();				new.format := e.format; new.hfactor := e.hfactor; new.vfactor := e.vfactor; new.row := e.row; new.col := e.col;				new.minx := e.minx; new.miny := e.miny; new.minw := e.minw; new.minh := e.minh;								objlist := LinkGadgets(e, NIL);				ReplaceElement(c, e, new, FALSE);				RETURN TRUE			ELSE (* c IS Container *)				head.next := c.dsc; f := head;				WHILE (f.next # NIL) & (f.next # e) DO f := f.next END;				IF f.next # NIL THEN	(* found *)					objlist := LinkGadgets(e, NIL);					f.next := f.next.next; c.dsc := head.next				END;				RETURN TRUE			END		END;		RETURN FALSE	END ClearElement;	(* --- *)				(** get top most selection (if any) or leaf Element, following u, v	border check if border IS TRUE	*)	PROCEDURE Select* (e: Element; u, v: INTEGER; border: BOOLEAN): Display.Frame;		VAR f, e1: Display.Frame; c: Container;	BEGIN		IF ~Effects.Inside(u, v, e.X, e.Y, e.W, e.H) THEN RETURN NIL		ELSIF border & Effects.InBorder(u, v, e.X, e.Y, e.W, e.H) THEN RETURN e		ELSIF Gadgets.selected IN e.state THEN RETURN e		ELSIF (e.obj # NIL) & (e.obj IS Display.Frame) THEN RETURN e.obj(Display.Frame)		ELSIF e IS Container THEN			c := e(Container); f := c.dsc; e1 := NIL;			WHILE (f # NIL) & (e1 = NIL) DO e1 := Select(f(Element), u, v, border); f := f.next END;			IF e1 # NIL THEN RETURN e1 ELSE RETURN e END		ELSE RETURN e		END	END Select;	(** returns closest Element in Table t for coordinates x, y *)	PROCEDURE ClosestTableElement* (t: Table; x, y: INTEGER): Element;		VAR f: Display.Frame; min: Element;	BEGIN		f := t.dsc; min := f(Element); (* table has at least one component *)		WHILE f # NIL DO			IF ABS(f.X + f.W DIV 2 - x) + ABS(f.Y + f.H DIV 2 - y) < ABS(min.X + min.W DIV 2 - x) + ABS(min.Y + min.H DIV 2 - y) THEN				min := f(Element)			END;			f := f.next		END;		RETURN min	END ClosestTableElement;	(* --- Handlers --- *)		PROCEDURE ElementHandler (obj: Objects.Object; VAR M: Objects.ObjMsg);		VAR mask: Display3.Mask; changed: BOOLEAN; A: Objects.AttrMsg; new: Element;  x, y: INTEGER;	BEGIN	END ElementHandler;		PROCEDURE ContainerHandler (obj: Objects.Object; VAR M: Objects.ObjMsg);		VAR f, fn, head: Display.Frame; changed: BOOLEAN; mask: Display3.Mask; D: Display.DisplayMsg; new: Container; x, y: INTEGER;	BEGIN	END ContainerHandler;	PROCEDURE TableHandler (obj: Objects.Object; VAR M: Objects.ObjMsg);		VAR f, fn, head: Display.Frame; i: INTEGER; changed: BOOLEAN; mask: Display3.Mask; D: Display.DisplayMsg; new: Table; x, y: INTEGER;	BEGIN	END TableHandler;	(* --- layout Procedures --- *)	PROCEDURE SizeElement (e: Element);		VAR hset, vset: SET;			(* get minw, minh if attributes exist, otherwise set to zero *)		PROCEDURE MinSize (obj: Display.Frame; VAR w, h: INTEGER);			VAR M: Objects.AttrMsg;		BEGIN			M.id := Objects.get; M.name := "minw"; M.res := -1; obj.handle(obj, M);			IF (M.res >= 0) & (M.class = Objects.Int) & (M.i >= 0) THEN w := SHORT(M.i)			ELSE				M.id := Objects.set; M.name := "minw"; M.res := -1; M.class := Objects.Int; M.i := obj.W; obj.handle(obj, M);				IF M.res >= 0 THEN w := obj.W ELSE w := 16 END			END;						M.id := Objects.get; M.name := "minh"; M.res := -1; obj.handle(obj, M);			IF (M.res >= 0) & (M.class = Objects.Int) & (M.i >= 0) THEN h := SHORT(M.i)			ELSE				M.id := Objects.set; M.name := "minh"; M.res := -1; M.class := Objects.Int; M.i := obj.H; obj.handle(obj, M);				IF M.res >= 0 THEN h := obj.H ELSE h := 16 END			END		END MinSize;	BEGIN		hset := {}; vset := {};		IF meleft IN e.format THEN INCL(hset, left) END;		IF meright IN e.format THEN INCL(hset, right) END;		IF mebottom IN e.format THEN INCL(vset, bottom) END;		IF metop IN e.format THEN INCL(vset, top) END;				(* overrider default table constraints *)		IF hset # {} THEN e.format := (e.format - {left, right}) + hset END;		IF vset # {} THEN e.format := (e.format - {bottom, top}) + vset END;				IF (e.obj # NIL) & (e.obj IS Display.Frame) THEN MinSize(e.obj(Display.Frame), e.minw, e.minh)		ELSE (* virtual or something else *)			IF e.minw < 10 THEN e.minw := 10 END;			IF e.minh < 10 THEN e.minh := 10 END		END	END SizeElement;	PROCEDURE SizeContainer (c: Element);		VAR f: Display.Frame;	BEGIN		WITH c: Container DO c.minw := 0; c.minh := 0;			f := c.dsc;			WHILE f # NIL DO				WITH f: Element DO f.size(f);					IF f.minx + f.minw > c.minw THEN c.minw := f.minx + f.minw END;					IF f.miny + f.minh > c.minh THEN c.minh := f.miny + f.minh END				END;				f := f.next			END;			SizeElement(c)			(*			IF c.minw < 10 THEN c.minw := 10 END;			IF c.minh < 10 THEN c.minh := 10 END			*)		END	END SizeContainer;	PROCEDURE SizeTable (t: Element);		VAR f: Display.Frame; i: INTEGER; set: SET;	BEGIN		WITH t: Table DO			FOR i := 0 TO t.cols - 1 DO t.gmaxw[i] := 0; t.hexpand[i] := 0 END;			FOR i := 0 TO t.rows - 1 DO t.gmaxh[i] := 0; t.vexpand[i] := 0 END;						set := {};			IF innerleft IN t.format THEN INCL(set, left) END; IF innerright IN t.format THEN INCL(set, right) END;			IF innertop IN t.format THEN INCL(set, top) END; IF innerbottom IN t.format THEN INCL(set, bottom) END;									f := t.dsc;			WHILE f # NIL DO				WITH f: Element DO					(* default Table constraints (hjustify, vjustify) *)										f.format := (f.format - {left..top}) + set;					f.size(f);										(* calculate minimal row, col sizes and factors *)					IF f.minw > t.gmaxw[f.col] THEN t.gmaxw[f.col] := f.minw END;					IF f.minh > t.gmaxh[f.row] THEN t.gmaxh[f.row] := f.minh END;					IF f.hfactor > t.hexpand[f.col] THEN t.hexpand[f.col] := f.hfactor END;					IF f.vfactor > t.vexpand[f.row] THEN t.vexpand[f.row] := f.vfactor END;				END;				f := f.next;			END;						(* calculate minw, minh, hfill, vfill of Table *)			t.minw := 2*t.hborder + (t.cols - 1)*t.hdist; t.hfill := 0;			t.minh := 2*t.vborder + (t.rows - 1)*t.vdist; t.vfill := 0;			FOR i := 0 TO t.cols - 1 DO INC(t.minw, t.gmaxw[i]); INC(t.hfill, t.hexpand[i]) END;			FOR i := 0 TO t.rows - 1 DO INC(t.minh, t.gmaxh[i]); INC(t.vfill, t.vexpand[i]) END;						SizeElement(t)	(* new *)		END	END SizeTable;		(* --- *)	(* aligns e according to e.format and propagates (if it exists) to Gadget *)	PROCEDURE MakeElement (e: Element; x, y, w, h: INTEGER);			PROCEDURE SetSize (F: Display.Frame; x, y, w, h: INTEGER);			VAR M: Display.ModifyMsg;		BEGIN			M.id := Display.extend; M.mode := Display.state; M.F := F;			(* simulated broadcast *)			Objects.Stamp(M); M.res := -1;			(* M.dlink := GetPanel(e); M.x := ...; M.y := ...; *)						M.X := x; M.Y := y; M.dX := M.X - F.X; M.dY := M.Y - F.Y;			M.W := w; M.H := h; M.dW := M.W - F.W; M.dH := M.H - F.H;			F.handle(F, M)	(* Display.Broadcast(M) is not allowed here!!! *)		END SetSize;	BEGIN		e.X := x; e.Y := y;				IF e.hfactor > 0 THEN e.W := w	(* fill out space *)		ELSE (* e.W := e.minw; *)	(* ? *)			IF right IN e.format THEN				IF left IN e.format THEN INC(e.X, (w - e.W) DIV 2)				ELSE INC(e.X, w - e.W)				END			ELSE				IF left IN e.format THEN (* nothing *)				ELSE	(* default is left *)				END			END		END;		IF e.vfactor > 0 THEN e.H := h		ELSE (* e.H := e.minh; *)			IF top IN e.format THEN				IF bottom IN e.format THEN INC(e.Y, (h - e.H) DIV 2)				ELSE INC(e.Y, h - e.H)				END			ELSE				IF bottom IN e.format THEN (* nothing *)				ELSE	(* default is bottom *)				END			END		END;		IF (e.obj # NIL) & (e.obj IS Display.Frame) THEN			SetSize(e.obj(Display.Frame), e.X, e.Y, e.W, e.H)		END	END MakeElement;	PROCEDURE MakePlace (c: Element; x, y, w, h: INTEGER);		VAR f: Display.Frame;	BEGIN		WITH c: Container DO			MakeElement(c, x, y, w, h);						f := c.dsc;			WHILE f # NIL DO				WITH f: Element DO					f.W := f.minw; f.H := f.minh;					f.make(f, c.X + c.hborder + f.minx, c.Y + c.vborder + f.miny, f.minw, f.minh)					END;				f := f.next			END		END	END MakePlace;			(* FillCols calculates column widths and row heights according to max, expand. result in max *)	PROCEDURE FillCols (space, cols, fills: INTEGER; expand, max: IntArray; sameSize: BOOLEAN);		VAR d, m, i: INTEGER; fillList: IntArray;	BEGIN		IF sameSize THEN			d := space DIV cols; m := space MOD cols;			FOR i := 0 TO cols - 1 DO INC(max[i], d) END;			FOR i := 0 TO m - 1 DO INC(max[i]) END		ELSIF space > 0 THEN			IF fills > 0 THEN				NEW(fillList, fills); m := 0;				FOR i := 0 TO cols - 1 DO					FOR d := 1 TO expand[i] DO fillList[m] := i; INC (m) END				END;				i := 0;				WHILE space > 0 DO d := fillList [i MOD fills];					IF max[d] < (i DIV fills)*expand[d] THEN INC (max[d]); DEC(space) END;					INC(i)				END			ELSE INC(max[cols-1], space)			END		END	END FillCols;	PROCEDURE SetOffset (cols, border, dist: INTEGER; max, offset: IntArray);		VAR i: INTEGER;	BEGIN offset[0] := border;		FOR i := 1 TO cols DO offset[i] := offset[i - 1]; INC(offset[i], max[i - 1] + dist) END	(* simplified expression *)	END SetOffset;	PROCEDURE MakeTable (t: Element; x, y, w, h: INTEGER);		VAR f: Display.Frame; x1, y1, w1, h1: INTEGER;	BEGIN		WITH t: Table DO			MakeElement(t, x, y, w, h);						FillCols(t.W - t.minw, t.cols, t.hfill, t.hexpand, t.gmaxw, t.format*{samewidth, hstatic} # {});			FillCols(t.H - t.minh, t.rows, t.vfill, t.vexpand, t.gmaxh, t.format*{sameheight, vstatic} # {});			SetOffset(t.cols, t.hborder, t.hdist, t.gmaxw, t.hoffset);			SetOffset(t.rows, t.vborder, t.vdist, t.gmaxh, t.voffset);						f := t.dsc;			WHILE f # NIL DO				WITH f: Element DO					(* rectangle of each element *)					x1 := t.hoffset[f.col]; w1 := t.hoffset[f.col + 1] - x1 - t.hdist; INC(x1, t.X);					y1 := t.voffset[f.row]; h1 := t.voffset[f.row + 1] - y1 - t.vdist; INC(y1, t.Y);					IF samewidth IN t.format THEN f.W := w1 ELSE f.W := f.minw END;					IF sameheight IN t.format THEN f.H := h1 ELSE f.H := f.minh END;					f.make(f, x1, y1, w1, h1)				END;				f := f.next			END		END	END MakeTable;	(* --- Generators for Objects --- *)		PROCEDURE InitElement (obj: Element);	BEGIN		obj.handle := ElementHandler; obj.size := SizeElement; obj.make := MakeElement;		obj.dsc := NIL; obj.next := NIL; obj.obj := NIL;		obj.format := {left, bottom, innerleft, innerbottom};		obj.X := 0; obj.Y := 0; obj.W := 0; obj.H := 0;		obj.minx := 0; obj.miny := 0; obj.minw := 10; obj.minh := 10; obj.hfactor := 0; obj.vfactor := 0;		obj.row := 0; obj.col := 0	END InitElement;		PROCEDURE NewElement* (): Element;		VAR obj: Element;	BEGIN NEW(obj); InitElement(obj); RETURN obj	END NewElement;			PROCEDURE InitContainer(obj: Container);	BEGIN InitElement(obj);		obj.handle := ContainerHandler; obj.size := SizeContainer; obj.make := MakePlace;		obj.hborder := 0; obj.vborder := 0	END InitContainer;		PROCEDURE NewContainer* (): Container;		VAR obj: Container;	BEGIN NEW(obj); InitContainer(obj); RETURN obj	END NewContainer;	PROCEDURE InitTable (obj: Table);	BEGIN InitContainer(obj);		obj.handle := TableHandler; obj.size := SizeTable; obj.make := MakeTable;		obj.rows := 1; obj.cols := 1; obj.hdist := 5; obj.vdist := 5;		NEW(obj.gmaxw, obj.cols); NEW(obj.hexpand, obj.cols); NEW(obj.gmaxh, obj.rows); NEW(obj.vexpand, obj.rows);		NEW(obj.hoffset, obj.cols + 1); NEW(obj.voffset, obj.rows + 1)	END InitTable;		PROCEDURE NewTable* (): Table;		VAR obj: Table;	BEGIN NEW(obj); InitTable(obj); RETURN obj	END NewTable;		(** creates an empty Table with rows*cols Elements *)	PROCEDURE EmptyTable* (rows, cols: INTEGER): Table;		VAR t: Table; f: Display.Frame; t0: Element; i, j: INTEGER;	BEGIN		t := NewTable(); t.cols := cols; t.rows := rows; t.hfactor := 1; t.vfactor := 1;		head.next := NIL; f := head;		FOR i := 0 TO rows - 1 DO			FOR j := 0 TO cols - 1 DO				t0 := NewElement(); f.next := t0; f := f.next;				WITH f: Element DO f.row := i; f.col := j; f.hfactor := 1; f.vfactor := 1 END			END		END;		f.next := NIL; t.dsc := head.next;		NEW(t.gmaxw, cols); NEW(t.hexpand, cols); NEW(t.hoffset, cols + 1);		NEW(t.gmaxh, rows); NEW(t.vexpand, rows); NEW(t.voffset, rows + 1);		RETURN t	END EmptyTable;	(* EBNF:	Object = "O" "(" ObjBody ")" | Container.	Container = ("P" | "T") "(" ObjBody {Object} ")".		ObjBody = {Set}.	Set = Ident "=" Value.		Ident = SmallLetter {SmallLetter}.	SmallLetter = "a".."z".	Value = Int.		Virtual: implicitly with id = 0.	*)	(** parses Text T and creates datastructure in obj,	T, lib # NIL	*)	PROCEDURE Parse* (T: Texts.Text; VAR obj: Element; lib: Objects.Library);	CONST		(* symbols *)		border = 0; cols = 1; grid = 3;		h = 4; hborder = 5; hfactor = 6; hdist = 7; hgrid = 8; hjustify = 9; hjustifyMe = 10; id = 11;		(* orientation = 11 *)		rows = 12;		sameHeight = 13; sameWidth = 14; sameSize = 15;		vborder = 16; vdist = 17; vfactor = 18; vgrid = 19; vjustify = 20; vjustifyMe = 21;		w = 22; x = 23; y = 24;		ident = 25;	(* unknown keyword *)	VAR		R: Texts.Reader;		ch: CHAR;	(* last read character *)			PROCEDURE Mark (str: ARRAY OF CHAR);		BEGIN			Texts.WriteString(W, "  pos: "); Texts.WriteInt(W, Texts.Pos(R), 11);			Texts.WriteString(W, "  "); Texts.WriteString(W, str);			Texts.WriteLn(W)		END Mark;			PROCEDURE Get (VAR ch: CHAR);		BEGIN REPEAT Texts.Read(R, ch) UNTIL (ch = 0X) OR (ch > " ")		END Get;						PROCEDURE Int (VAR x: INTEGER);			VAR neg: BOOLEAN;		BEGIN			neg := ch = "-"; IF neg THEN Get(ch) END;			x := ORD(ch) - ORD("0"); Get(ch);			WHILE (ch >= "0") & (ch <= "9") DO x := 10*x + ORD(ch) - ORD("0"); Get(ch) END;			IF neg THEN x := -x END		END Int;				PROCEDURE ObjBody(obj: Element);		VAR			key, val: INTEGER; t: Objects.Object;						PROCEDURE Ident (): SHORTINT;				VAR ch1: CHAR;			BEGIN ch1 := ch; Get(ch);				CASE ch1 OF				   "b": RETURN border				| "c": RETURN cols				| "g": RETURN grid				| "h": ch1 := ch;					CASE ch1 OF					  "b": Get(ch); RETURN hborder					| "d": Get(ch); RETURN hdist					| "f": Get(ch); RETURN hfactor					| "g": Get(ch); RETURN hgrid					| "j": Get(ch); RETURN hjustify					| "m": Get(ch); RETURN hjustifyMe					ELSE RETURN h					END				| "i": RETURN id				| "r": RETURN rows				| "s": ch1 := ch; Get(ch);					CASE ch1 OF					   "h": RETURN sameHeight					| "w": RETURN sameWidth					| "s": RETURN sameSize					END				| "v": ch1 := ch; Get(ch);					CASE ch1 OF						   "b": RETURN vborder						| "d": RETURN vdist						| "f": RETURN vfactor						| "g": RETURN vgrid						| "j": RETURN vjustify						| "m": RETURN vjustifyMe					ELSE					END				| "w": RETURN w				| "x": RETURN x				| "y": RETURN y				ELSE				END;				Mark("unknown keyword"); RETURN ident			END Ident;		BEGIN			WHILE (ch >= "a") & (ch <= "z") DO (* Set *)				key := Ident();				IF ch = "=" THEN					Get(ch); Int(val);										IF obj IS Container THEN								IF obj IS Table THEN							WITH obj: Table DO								CASE key OF								   cols: obj.cols := val; NEW(obj.gmaxw, val); NEW(obj.hexpand, val); NEW(obj.hoffset, val + 1)								| rows: obj.rows := val; NEW(obj.gmaxh, val); NEW(obj.vexpand, val); NEW(obj.voffset, val + 1)								| hdist: obj.hdist := val								| vdist: obj.vdist := val								| sameSize:									IF val = 1 THEN obj.format := obj.format + {samewidth, sameheight}									ELSE obj.format := obj.format - {samewidth, sameheight}									END								| sameHeight: IF val = 1 THEN INCL(obj.format, samewidth) ELSE EXCL(obj.format, samewidth) END								| sameWidth: IF val = 1 THEN INCL(obj.format, sameheight) ELSE EXCL(obj.format, sameheight) END								| grid:									IF val = 1 THEN obj.format := obj.format + {hstatic, vstatic}									ELSE obj.format := obj.format - {hstatic, vstatic}									END								| hgrid: IF val = 1 THEN INCL(obj.format, hstatic) ELSE EXCL(obj.format, hstatic) END								| vgrid: IF val = 1 THEN INCL(obj.format, vstatic) ELSE EXCL(obj.format, vstatic) END								| hjustify:									CASE val OF									   0: (* undef *) obj.format := obj.format - {innerleft, innerright}	(* unnecessary *)									| 1: (* left *) INCL(obj.format, innerleft); EXCL(obj.format, innerright)									| 2: (* right *) INCL(obj.format, innerright); EXCL(obj.format, innerleft)									| 3: (* center *) obj.format := obj.format + {innerleft, innerright}									ELSE									END								| vjustify:									CASE val OF									   0: (* undef *) obj.format := obj.format - {innerbottom, innertop}	(* unnecessary *)									| 1: (* bottom *) INCL(obj.format, innerbottom); EXCL(obj.format, innertop)									| 2: (* top *) INCL(obj.format, innertop); EXCL(obj.format, innerbottom)									| 3: (* center *) obj.format := obj.format + {innerbottom, innertop}									ELSE									END								ELSE								END							END						END;						WITH obj: Container DO							CASE key OF							   border: obj.hborder := val; obj.vborder := val							| hborder: obj.hborder := val							| vborder: obj.vborder := val							ELSE							END						END					END;													CASE key OF					   hjustifyMe:						CASE val OF						   0: (* undef *) obj.format := obj.format - {meleft, meright}	(* unnecessary *)						| 1: (* left *) INCL(obj.format, meleft); EXCL(obj.format, meright)						| 2: (* right *) INCL(obj.format, meright); EXCL(obj.format, meleft)						| 3: (* center *) obj.format := obj.format + {meleft, meright}						ELSE						END					| vjustifyMe:						CASE val OF							   0: (* undef *) obj.format := obj.format - {mebottom, metop}	(* unnecessary *)							| 1: (* bottom *) INCL(obj.format, mebottom); EXCL(obj.format, metop)							| 2: (* top *) INCL(obj.format, metop); EXCL(obj.format, mebottom)							| 3: (* center *) obj.format := obj.format + {mebottom, metop}						ELSE (* ignore *)						END					| hfactor: obj.hfactor := val					| vfactor: obj.vfactor := val					| x: obj.minx := val					| y: obj.miny := val					| w: obj.minw := val					| h: obj.minh := val					| id: lib.GetObj(lib, val, t); IF t IS Display.Frame THEN obj.obj := t(Display.Frame) END (* get library object for ref = val, change this !!! *)					ELSE					END				ELSE Mark("=?")				END			END		END ObjBody;		PROCEDURE Object (VAR obj: Element);			VAR head, f: Display.Frame; t: Element; i, j: INTEGER;		BEGIN NEW(head); (* new head for each recursion *)			CASE ch OF			   "O":	(* Element *)		   	obj := NewElement(); Get(ch);		   	IF ch = "(" THEN			   	Get(ch); ObjBody(obj);			   	IF ch = ")" THEN Get(ch)			   	ELSE Mark(")?")			   	END			   ELSE Mark("(?")			   END			   			| "P":	(* Place Container *)				obj := NewContainer(); Get(ch);				IF ch = "(" THEN					Get(ch); ObjBody(obj);					IF ch # ")" THEN						head.next := NIL; f := head;						WHILE ch # ")" DO							Object(t); f.next := t; f := f.next						END;						f.next := NIL; obj.dsc := head.next					ELSE Mark("Object?")					END;					Get(ch)				ELSE Mark("(?")				END							| "T":	(* Table Container *)				obj := NewTable(); Get(ch);				IF ch = "(" THEN					Get(ch); ObjBody(obj);					IF ch # ")" THEN						i := 0; j := 0; head.next := NIL; f := head;						WHILE ch # ")" DO Object(t); f.next := t; f := f.next; f(Element).row := i; f(Element).col := j;							INC(j);							IF j >= obj(Table).cols THEN j := 0; INC(i) END						END;						f.next := NIL; obj.dsc := head.next					ELSE Mark("Object?")					END;					Get(ch)				ELSE Mark("(?")				END							ELSE Mark("not an Object")			END		END Object;		BEGIN		Texts.OpenReader(R, T, 0);		 Get(ch); Object(obj)	END Parse;		(* --- *)	(** traverses datastructure in e and produces Text T *)	PROCEDURE Produce* (e: Element; T: Texts.Text);		VAR W: Texts.Writer;				PROCEDURE Put (ch: CHAR); BEGIN Texts.Write(W, ch) END Put;		PROCEDURE PutStr (str: ARRAY OF CHAR); BEGIN Texts.WriteString(W, str) END PutStr;		PROCEDURE PutInt (x: LONGINT);			VAR a: ARRAY 11 OF CHAR; i: INTEGER;		BEGIN			IF x < 0 THEN				IF x = MIN(LONGINT) THEN PutStr("-2147483648"); RETURN				ELSE Put("-"); x := -x				END			END;			i := 0;			REPEAT a[i] := CHR(x MOD 10 + ORD("0")); INC(i); x := x DIV 10 UNTIL x = 0;			REPEAT DEC(i); Put(a[i]) UNTIL i = 0		END PutInt;		PROCEDURE element (e: Element; place: BOOLEAN);			VAR f: Display.Frame;		BEGIN			(* kind *)			IF e IS Table THEN PutStr("T(")			ELSIF e IS Container THEN PutStr("P(")			ELSE PutStr("O(")			END;						(* --- ObjBody --- *)			(* table *)			IF e IS Table THEN				WITH e: Table DO					IF e.cols # 1 THEN PutStr("c="); PutInt(e.cols) END;					IF e.rows # 1 THEN PutStr("r="); PutInt(e.rows) END;					IF e.hdist # 5 THEN PutStr("hd="); PutInt(e.hdist) END;					IF e.vdist # 5 THEN PutStr("vd="); PutInt(e.vdist) END;					IF (samewidth IN e.format) & (sameheight IN e.format) THEN PutStr("ss=1")	(* simplify expression *)					ELSIF samewidth IN e.format THEN PutStr("sw=1")					ELSIF sameheight IN e.format THEN PutStr("sh=1")					END;					IF (hstatic IN e.format) & (vstatic IN e.format) THEN PutStr("g=1")	(* simplify expression *)					ELSIF hstatic IN e.format THEN PutStr("hg=1")					ELSIF vstatic IN e.format THEN PutStr("vg=1")					END;					IF innerleft IN e.format THEN						IF innerright IN e.format THEN PutStr("hj=3")						ELSE PutStr("hj=1")						END					ELSIF innerright IN e.format THEN PutStr("hj=2")					END;					IF innerbottom IN e.format THEN						IF innertop IN e.format THEN PutStr("vj=3")						ELSE PutStr("vj=1")						END					ELSIF innertop IN e.format THEN PutStr("vj=2")					END				END			END;						(* container *)			IF e IS Container THEN				WITH e: Container DO					IF (e.hborder # 0) & (e.hborder = e.vborder) THEN PutStr("b="); PutInt(e.hborder)					ELSIF e.hborder # 0 THEN PutStr("hb="); PutInt(e.hborder)					ELSIF e.vborder # 0 THEN PutStr("vb="); PutInt(e.vborder)					END				END			END;									(* Element  *)						IF ~(e IS Container) & (e.obj # NIL) THEN PutStr("i="); PutInt(e.obj.ref) END;					IF meleft IN e.format THEN				IF meright IN e.format THEN PutStr("hm=3")				ELSE PutStr("hm=1")				END			ELSIF meright IN e.format THEN PutStr("hm=2")				END;						IF mebottom IN e.format THEN				IF metop IN e.format THEN PutStr("vm=3")				ELSE PutStr("vm=1")				END			ELSIF metop IN e.format THEN PutStr("vm=2")				END;						IF place THEN	(* parent is place *)				IF e.minx # 0 THEN PutStr("x="); PutInt(e.minx) END;				IF e.miny # 0 THEN PutStr("y="); PutInt(e.miny) END			END;						IF ~(e IS Container) THEN				IF e.minw # 0 THEN PutStr("w="); PutInt(e.minw) END;				IF e.minh # 0 THEN PutStr("h="); PutInt(e.minh) END			END;			IF e.hfactor # 0 THEN PutStr("hf="); PutInt(e.hfactor) END;			IF e.vfactor # 0 THEN PutStr("vf="); PutInt(e.vfactor) END;						(* Objects *)			IF e IS Container THEN f := e(Container).dsc;				WHILE f # NIL DO element(f(Element), ~(e IS Table)); f := f.next END			END;						Put(")")		END element;		BEGIN		Texts.OpenWriter(W);		element(e, FALSE);		Texts.Delete(T, 0, T.len); Texts.Append(T, W.buf)	END Produce;			(* --- select procedures --- *)		(** get top most selection *)	PROCEDURE GetSelection* (e: Element): Display.Frame;		VAR f, e1: Display.Frame;	BEGIN		IF Gadgets.selected IN e.state THEN RETURN e		ELSIF (e.obj # NIL) & (e.obj IS Gadgets.Frame) & (Gadgets.selected IN e.obj(Gadgets.Frame).state) THEN RETURN e.obj(Display.Frame)		ELSIF e IS Container THEN f := e(Container).dsc; e1 := NIL;			WHILE (f # NIL) & (e1 = NIL) DO e1 := GetSelection(f(Element)); f := f.next END;			RETURN e1		ELSE RETURN NIL		END	END GetSelection;	(* --- Debugging Procedures --- *)	PROCEDURE Info* (e: Display.Frame);	BEGIN		Texts.WriteString(W, "x = "); Texts.WriteInt(W, e.X, 5);		Texts.WriteString(W, "  y = "); Texts.WriteInt(W, e.Y, 5);		Texts.WriteString(W, "  w = "); Texts.WriteInt(W, e.W, 5);		Texts.WriteString(W, "  h = "); Texts.WriteInt(W, e.H, 5);		IF e IS Element THEN			WITH e: Element DO				Texts.WriteString(W, "  minx = "); Texts.WriteInt(W, e.minx, 5);				Texts.WriteString(W, "  miny = "); Texts.WriteInt(W, e.miny, 5);				Texts.WriteString(W, "  minw = "); Texts.WriteInt(W, e.minw, 5);				Texts.WriteString(W, "  minh = "); Texts.WriteInt(W, e.minh, 5);				Texts.WriteLn(W);				IF e IS Container THEN					WITH e: Container DO						Texts.WriteString(W, "hborder = "); Texts.WriteInt(W, e.hborder, 5);						Texts.WriteString(W, "vborder = "); Texts.WriteInt(W, e.vborder, 5);						Texts.WriteLn(W)					END;					IF e IS Table THEN						WITH e: Table DO							Texts.WriteString(W, "table  ");							Texts.WriteString(W, "cols = "); Texts.WriteInt(W, e.cols, 5);							Texts.WriteString(W, "rows = "); Texts.WriteInt(W, e.rows, 5);							Texts.WriteString(W, "hdist = "); Texts.WriteInt(W, e.hdist, 5);							Texts.WriteString(W, "vdist = "); Texts.WriteInt(W, e.vdist, 5);							Texts.WriteString(W, "hfill = "); Texts.WriteInt(W, e.hfill, 5);							Texts.WriteString(W, "vfill = "); Texts.WriteInt(W, e.vfill, 5);							Texts.WriteLn(W)						END					END				END			END		END	END Info;	(** call with depth = 0 *)	PROCEDURE DebugElements* (e: Element; depth: INTEGER);		VAR i: INTEGER; f: Display.Frame;	BEGIN		FOR i := 0 TO depth - 1 DO Texts.Write(W, 9X) END;		Texts.WriteString(W, "x = "); Texts.WriteInt(W, e.X, 5);		Texts.WriteString(W, "  y = "); Texts.WriteInt(W, e.Y, 5);		Texts.WriteString(W, "  w = "); Texts.WriteInt(W, e.W, 5);		Texts.WriteString(W, "  h = "); Texts.WriteInt(W, e.H, 5);		Texts.WriteString(W, "  minx = "); Texts.WriteInt(W, e.minx, 5);		Texts.WriteString(W, "  miny = "); Texts.WriteInt(W, e.miny, 5);		Texts.WriteString(W, "  minw = "); Texts.WriteInt(W, e.minw, 5);		Texts.WriteString(W, "  minh = "); Texts.WriteInt(W, e.minh, 5);		Texts.WriteLn(W);		IF e IS Container THEN f := e(Container).dsc;			WHILE f # NIL DO DebugElements(f(Element), depth + 1); f := f.next END		END	END DebugElements;BEGIN	Texts.OpenWriter(W);	NEW(head)END LayoutPanels0.ÛBIERjà  ƒà   Àß  åß  à  :à           
 
 ÿÿ    ÿÿCName Rect    *       
 
 ÿÿ    ÿÿCCmd Watson.Goto Mask           
 
 ÿÿ    ÿÿCName Rect    *       
 
 ÿÿ    ÿÿCCmd Watson.Goto Mask   TextGadgets.NewControl  €